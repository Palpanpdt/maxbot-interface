<!DOCTYPE html>
<html>
<head>DOCTYPE html>
    <title>MaxBot Professional Controller</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Bibliothèques externes -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.8.1/dist/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- Les styles CSS seront chargés dans une section séparée -->
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="logo">
                <div class="logo-icon"></div>
                <h1>MaxBot Professional</h1>
            </div>
            <div class="wallet-info" id="walletContainer">
                <button id="connectBtn" class="connect-btn">Connecter à MetaMask</button>
            </div>
        </div>
        
        <div class="tabs">
            <div class="tab active" data-tab="dashboard">Tableau de bord</div>
            <div class="tab" data-tab="flashloans">Flash Loans</div>
            <div class="tab" data-tab="arbitrage">Arbitrage</div>
            <div class="tab" data-tab="liquidations">Liquidations</div>
            <div class="tab" data-tab="settings">Paramètres</div>
            <div class="tab" data-tab="extensions">Extensions</div>
        </div>
        
        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboard-content">
            <div class="card-grid">
                <div class="card">
                    <h3 class="card-title">Profit Total</h3>
                    <p class="card-value">0.00 MATIC</p>
                    <p class="card-footer">Dernières 24h: <span class="card-positive">+0.00 MATIC</span></p>
                </div>
                <div class="card">
                    <h3 class="card-title">Transactions</h3>
                    <p class="card-value">0</p>
                    <p class="card-footer">Réussies: 0 | Échouées: 0</p>
                </div>
                <div class="card">
                    <h3 class="card-title">Capital Déployé</h3>
                    <p class="card-value">0.00 USDC</p>
                    <p class="card-footer">Max: 0.00 USDC</p>
                </div>
                <div class="card">
                    <h3 class="card-title">Statut du Bot</h3>
                    <p class="card-value">
                        <span class="status-indicator status-inactive" id="botStatusIndicator"></span>
                        <span id="botStatusText">Inactif</span>
                    </p>
                    <p class="card-footer" id="networkInfo">Non connecté</p>
                </div>
            </div>
            
            <div class="panel">
                <h2>Performance</h2>
                <div class="chart-container">
                    <canvas id="profitChart"></canvas>
                </div>
            </div>
            
            <div class="panel">
                <h2>Transactions Récentes</h2>
                <table class="transactions-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Type</th>
                            <th>Montant</th>
                            <th>Profit</th>
                            <th>Hash</th>
                            <th>Statut</th>
                        </tr>
                    </thead>
                    <tbody id="transactionsTable">
                        <tr>
                            <td colspan="6" style="text-align: center;">Aucune transaction à afficher</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Flash Loans Tab -->
        <div class="tab-content" id="flashloans-content">
            <div class="panel">
                <h2>Exécution de Flash Loan</h2>
                <div class="form-row">
                    <div class="form-control">
                        <label for="flashloan-token">Token</label>
                        <select id="flashloan-token">
                            <option value="USDC">USDC</option>
                            <option value="WMATIC">WMATIC</option>
                            <option value="WETH">WETH</option>
                            <option value="WBTC">WBTC</option>
                            <option value="DAI">DAI</option>
                        </select>
                    </div>
                    <div class="form-control">
                        <label for="flashloan-amount">Montant</label>
                        <input type="text" id="flashloan-amount" value="1000" placeholder="Montant">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-control">
                        <label for="flashloan-gas-price">Prix du gaz (Gwei)</label>
                        <input type="number" id="flashloan-gas-price" value="50" min="1" max="500">
                    </div>
                    <div class="form-control">
                        <label for="flashloan-gas-limit">Limite de gaz</label>
                        <input type="number" id="flashloan-gas-limit" value="3000000" min="500000" max="10000000">
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <button id="forceExecuteFlashloanBtn" class="action-button" disabled>Exécuter Flash Loan Direct</button>
                    <button id="checkFlashloanOpportunityBtn" class="action-button" disabled>Vérifier Opportunité</button>
                </div>
                
                <div class="logs-container" id="flashloanLogs">
                    <div class="log-entry log-info">
                        <span class="log-time">[00:00:00]</span> Connectez-vous pour commencer.
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Automatisation des Flash Loans</h2>
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Mode automatique</span>
                        <span class="settings-description">Le bot exécutera automatiquement des flash loans quand des opportunités sont détectées</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="flashloan-auto-mode" disabled>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Seuil de profit minimum</span>
                        <span class="settings-description">N'exécuter que si le profit estimé dépasse ce montant</span>
                    </div>
                    <div class="form-control" style="max-width: 100px;">
                        <input type="text" id="flashloan-min-profit" value="0.01" disabled>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Intervalle de vérification (sec)</span>
                        <span class="settings-description">Fréquence à laquelle le bot vérifie les opportunités</span>
                    </div>
                    <div class="form-control" style="max-width: 100px;">
                        <input type="number" id="flashloan-check-interval" value="30" min="10" max="3600" disabled>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Arbitrage Tab -->
        <div class="tab-content" id="arbitrage-content">
            <div class="panel">
                <h2>Vérification d'Arbitrage</h2>
                <div class="form-row">
                    <div class="form-control">
                        <label for="arbitrage-token-a">Token A</label>
                        <select id="arbitrage-token-a">
                            <option value="USDC">USDC</option>
                            <option value="WMATIC">WMATIC</option>
                            <option value="WETH">WETH</option>
                            <option value="WBTC">WBTC</option>
                            <option value="DAI">DAI</option>
                        </select>
                    </div>
                    <div class="form-control">
                        <label for="arbitrage-token-b">Token B</label>
                        <select id="arbitrage-token-b">
                            <option value="WMATIC">WMATIC</option>
                            <option value="USDC">USDC</option>
                            <option value="WETH">WETH</option>
                            <option value="WBTC">WBTC</option>
                            <option value="DAI">DAI</option>
                        </select>
                    </div>
                    <div class="form-control">
                        <label for="arbitrage-amount">Montant à trader</label>
                        <input type="text" id="arbitrage-amount" value="100" placeholder="Montant">
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <button id="checkArbitrageBtn" class="action-button" disabled>Vérifier Opportunité</button>
                    <button id="executeArbitrageBtn" class="action-button" disabled>Exécuter Arbitrage</button>
                </div>
                
                <div class="logs-container" id="arbitrageLogs">
                    <div class="log-entry log-info">
                        <span class="log-time">[00:00:00]</span> Connectez-vous pour commencer.
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Stratégies d'Arbitrage</h2>
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Mode automatique</span>
                        <span class="settings-description">Le bot recherchera et exécutera automatiquement des arbitrages</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="arbitrage-auto-mode" disabled>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Paires à surveiller</span>
                        <span class="settings-description">Tokens entre lesquels rechercher des opportunités</span>
                    </div>
                    <div style="text-align: right;">
                        <button id="editPairsBtn" class="action-button" disabled style="margin: 0;">Modifier</button>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Seuil de profit minimum (%)</span>
                        <span class="settings-description">N'exécuter que si le profit estimé dépasse ce pourcentage</span>
                    </div>
                    <div class="form-control" style="max-width: 100px;">
                        <input type="text" id="arbitrage-min-profit" value="0.5" disabled>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Liquidations Tab -->
        <div class="tab-content" id="liquidations-content">
            <div class="panel">
                <h2>Moniteur de Liquidations</h2>
                <div class="card-grid">
                    <div class="card">
                        <h3 class="card-title">Opportunités de Liquidation</h3>
                        <p class="card-value">0</p>
                        <p class="card-footer">Dernières 24h: 0</p>
                    </div>
                    <div class="card">
                        <h3 class="card-title">Liquidations Exécutées</h3>
                        <p class="card-value">0</p>
                        <p class="card-footer">Total: 0</p>
                    </div>
                    <div class="card">
                        <h3 class="card-title">Profit Moyen</h3>
                        <p class="card-value">0.00 MATIC</p>
                        <p class="card-footer">Maximum: 0.00 MATIC</p>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <button id="startLiquidationScanBtn" class="action-button" disabled>Démarrer Scan</button>
                    <button id="stopLiquidationScanBtn" class="action-button" disabled>Arrêter Scan</button>
                </div>
                
                <div class="logs-container" id="liquidationLogs">
                    <div class="log-entry log-info">
                        <span class="log-time">[00:00:00]</span> Connectez-vous pour commencer.
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Configuration des Liquidations</h2>
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Mode automatique</span>
                        <span class="settings-description">Le bot exécutera automatiquement les liquidations</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="liquidation-auto-mode" disabled>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Pools à surveiller</span>
                        <span class="settings-description">Plateformes sur lesquelles rechercher des liquidations</span>
                    </div>
                    <div style="text-align: right;">
                        <button id="editPoolsBtn" class="action-button" disabled style="margin: 0;">Modifier</button>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Capital maximum par liquidation</span>
                        <span class="settings-description">Montant maximum à utiliser pour une seule liquidation</span>
                    </div>
                    <div class="form-control" style="max-width: 100px;">
                        <input type="text" id="liquidation-max-capital" value="250000" disabled>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Settings Tab -->
        <div class="tab-content" id="settings-content">
            <div class="panel">
                <h2>Paramètres Généraux</h2>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Interface thème sombre</span>
                        <span class="settings-description">Utiliser un thème sombre pour l'interface</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="dark-mode" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Notifications</span>
                        <span class="settings-description">Afficher des notifications pour les événements importants</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="notifications-enabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Adresse du contrat</span>
                        <span class="settings-description">L'adresse de votre contrat MaxBot sur Polygon</span>
                    </div>
                    <div class="form-control" style="max-width: 250px;">
                        <input type="text" id="contract-address" value="0xb6e34063afc9072d76353135918f2cb11a2e54a7">
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <span class="settings-title">Limites de sécurité</span>
                        <span class="settings-description">Protection contre les erreurs d'exécution</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="safety-limits" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Extensions Tab -->
<div class="tab-content" id="extensions-content">
    <div class="panel">
        <h2>MorpheusTrader</h2>
        <div class="form-row">
            <div class="form-control">
                <label for="morpheus-token-in">Token d'entrée</label>
                <select id="morpheus-token-in">
                    <option value="USDC">USDC</option>
                    <option value="WMATIC">WMATIC</option>
                    <option value="WETH">WETH</option>
                    <option value="WBTC">WBTC</option>
                    <option value="DAI">DAI</option>
                </select>
            </div>
            <div class="form-control">
                <label for="morpheus-token-out">Token de sortie</label>
                <select id="morpheus-token-out">
                    <option value="WMATIC">WMATIC</option>
                    <option value="USDC">USDC</option>
                    <option value="WETH">WETH</option>
                    <option value="WBTC">WBTC</option>
                    <option value="DAI">DAI</option>
                </select>
            </div>
            <div class="form-control">
                <label for="morpheus-amount">Montant</label>
                <input type="text" id="morpheus-amount" value="100" placeholder="Montant">
            </div>
        </div>
        
        <div class="form-row">
            <div class="form-control">
                <label for="morpheus-slippage">Slippage Max (%)</label>
                <input type="number" id="morpheus-slippage" value="1" min="0.1" max="5" step="0.1">
            </div>
            <div class="form-control">
                <label for="morpheus-mev">Protection MEV</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="morpheus-mev" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button id="findBestRouteBtn" class="action-button" disabled>Trouver le meilleur itinéraire</button>
            <button id="executeWithMorpheusBtn" class="action-button" disabled>Exécuter avec MorpheusTrader</button>
        </div>
        
        <div class="logs-container" id="morpheusLogs">
            <div class="log-entry log-info">
                <span class="log-time">[00:00:00]</span> Connectez-vous pour commencer à utiliser MorpheusTrader.
            </div>
        </div>
    </div>
    
    <div class="panel">
        <h2>Scanner Service</h2>
        <div class="settings-row">
            <div class="settings-label">
                <span class="settings-title">Scanner automatique</span>
                <span class="settings-description">Détection automatique des opportunités</span>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="scanner-auto-mode" disabled>
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <div class="settings-row">
            <div class="settings-label">
                <span class="settings-title">Niveau de confiance minimum (%)</span>
                <span class="settings-description">N'alerter que si la confiance dans l'opportunité dépasse ce seuil</span>
            </div>
            <div class="form-control" style="max-width: 100px;">
                <input type="number" id="scanner-confidence" value="80" min="50" max="99" disabled>
            </div>
        </div>
        
        <h3 style="margin-top: 20px;">Opportunités détectées</h3>
        <table class="transactions-table">
            <thead>
                <tr>
                    <th>Timestamp</th>
                    <th>Paire</th>
                    <th>Profit estimé</th>
                    <th>Confiance</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody id="opportunitiesTable">
                <tr>
                    <td colspan="5" style="text-align: center;">Aucune opportunité à afficher</td>
                </tr>
            </tbody>
        </table>
    </div>
    
    <div class="panel">
        <h2>ML Optimizer</h2>
        <div class="settings-row">
            <div class="settings-label">
                <span class="settings-title">Optimisation automatique</span>
                <span class="settings-description">Ajuster automatiquement les paramètres via ML</span>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="ml-auto-mode" disabled>
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <div class="card-grid">
            <div class="card">
                <h3 class="card-title">Performances ML</h3>
                <p class="card-value">0%</p>
                <p class="card-footer">Amélioration: +0%</p>
            </div>
            <div class="card">
                <h3 class="card-title">Dernière mise à jour</h3>
                <p class="card-value">Jamais</p>
                <p class="card-footer">Épisodes: 0</p>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button id="forceMLUpdateBtn" class="action-button" disabled>Forcer mise à jour</button>
            <button id="resetMLBtn" class="action-button" disabled>Réinitialiser ML</button>
        </div>
        
        <div class="logs-container" id="mlLogs">
            <div class="log-entry log-info">
                <span class="log-time">[00:00:00]</span> Connectez-vous pour utiliser l'optimisation ML.
            </div>
        </div>
    </div>
    
    <div class="panel">
        <h2>Configuration des extensions</h2>
        <div class="settings-row">
            <div class="settings-label">
                <span class="settings-title">Adresse MorpheusTrader</span>
                <span class="settings-description">L'adresse du contrat MorpheusTrader</span>
            </div>
            <div class="form-control" style="max-width: 250px;">
                <input type="text" id="morpheus-address" placeholder="0x...">
            </div>
        </div>
        
        <div class="settings-row">
            <div class="settings-label">
                <span class="settings-title">Adresse ScannerService</span>
                <span class="settings-description">L'adresse du service de scan</span>
            </div>
            <div class="form-control" style="max-width: 250px;">
                <input type="text" id="scanner-address" placeholder="0x...">
            </div>
        </div>
        
        <div class="settings-row">
            <div class="settings-label">
                <span class="settings-title">Adresse MLOptimizer</span>
                <span class="settings-description">L'adresse du service d'optimisation ML</span>
            </div>
            <div class="form-control" style="max-width: 250px;">
                <input type="text" id="ml-address" placeholder="0x...">
            </div>
        </div>
        
        <div style="margin-top: 20px; text-align: right;">
            <button id="setExtensionsBtn" class="action-button" disabled>Enregistrer les adresses</button>
        </div>
    </div>
</div>
    <!-- Scripts chargés en bas de page -->
     <!-- Ajouter après la ligne 82 dans le HTML -->
<div class="panel debug-panel">
    <h2>Débogage et Diagnostics</h2>
    <div class="form-row">
        <button id="debugNetworkBtn" class="action-button">Vérifier Réseau</button>
        <button id="debugContractBtn" class="action-button">Diagnostiquer Contrat</button>
        <button id="debugTransactionBtn" class="action-button">Simuler Transaction</button>
    </div>
    <div class="logs-container" id="debugLogs">
        <div class="log-entry log-info">
            <span class="log-time">[Diagnostic]</span> Utilisez ces boutons pour résoudre les problèmes.
        </div>
    </div>
</div>

<!-- Ajouter le script correspondant -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Ajouter les fonctions de débogage
    document.getElementById('debugNetworkBtn').addEventListener('click', async function() {
        const debugLogs = document.getElementById('debugLogs');
        debugLogs.innerHTML = '<div class="log-entry log-info"><span class="log-time">[Diagnostic]</span> Vérification du réseau...</div>';
        
        try {
            // Vérifier le réseau
            const chainId = await web3.eth.getChainId();
            let networkName;
            switch(chainId) {
                case 1: networkName = "Ethereum Mainnet"; break;
                case 137: networkName = "Polygon Mainnet"; break;
                case 80001: networkName = "Polygon Mumbai Testnet"; break;
                default: networkName = `ID de chaîne inconnu: ${chainId}`;
            }
            
            // Vérifier le solde
            const balance = await web3.eth.getBalance(userAccount);
            const balanceEth = web3.utils.fromWei(balance, 'ether');
            
            debugLogs.innerHTML += `
                <div class="log-entry log-success">
                    <span class="log-time">[Réseau]</span> Connecté à ${networkName}
                </div>
                <div class="log-entry log-info">
                    <span class="log-time">[Compte]</span> ${userAccount}
                </div>
                <div class="log-entry log-info">
                    <span class="log-time">[Solde]</span> ${balanceEth} ${chainId == 137 ? 'MATIC' : 'ETH'}
                </div>
            `;
        } catch (error) {
            debugLogs.innerHTML += `
                <div class="log-entry log-error">
                    <span class="log-time">[Erreur]</span> ${error.message}
                </div>
            `;
        }
    });
    
    document.getElementById('debugContractBtn').addEventListener('click', async function() {
        const debugLogs = document.getElementById('debugLogs');
        const contractAddress = document.getElementById('contract-address').value;
        
        debugLogs.innerHTML = `
            <div class="log-entry log-info">
                <span class="log-time">[Diagnostic]</span> Vérification du contrat à l'adresse ${contractAddress}...
            </div>
        `;
        
        try {
            // Vérifier si le contrat existe
            const code = await web3.eth.getCode(contractAddress);
            if (code === '0x' || code === '0x0') {
                debugLogs.innerHTML += `
                    <div class="log-entry log-error">
                        <span class="log-time">[Contrat]</span> Aucun contrat déployé à cette adresse!
                    </div>
                `;
                return;
            }
            
            debugLogs.innerHTML += `
                <div class="log-entry log-success">
                    <span class="log-time">[Contrat]</span> Contrat détecté à l'adresse ${contractAddress}
                </div>
            `;
            
            // Tester les méthodes principales
            const methods = ['forceExecuteFlashLoan', 'checkArbitrageOpportunity', 'isOperational'];
            for (const method of methods) {
                try {
                    if (!contract.methods[method]) {
                        debugLogs.innerHTML += `
                            <div class="log-entry log-warning">
                                <span class="log-time">[Méthode]</span> ${method} n'existe pas dans l'ABI
                            </div>
                        `;
                        continue;
                    }
                    
                    // Pour les méthodes view simples, essayer de les appeler
                    if (method === 'isOperational') {
                        const result = await contract.methods[method]().call();
                        debugLogs.innerHTML += `
                            <div class="log-entry log-success">
                                <span class="log-time">[${method}]</span> Résultat: ${result}
                            </div>
                        `;
                    } else {
                        debugLogs.innerHTML += `
                            <div class="log-entry log-info">
                                <span class="log-time">[${method}]</span> Présent dans l'ABI
                            </div>
                        `;
                    }
                } catch (methodError) {
                    debugLogs.innerHTML += `
                        <div class="log-entry log-error">
                            <span class="log-time">[${method}]</span> Erreur: ${methodError.message}
                        </div>
                    `;
                }
            }
        } catch (error) {
            debugLogs.innerHTML += `
                <div class="log-entry log-error">
                    <span class="log-time">[Erreur]</span> ${error.message}
                </div>
            `;
        }
    });
    
    document.getElementById('debugTransactionBtn').addEventListener('click', async function() {
        const debugLogs = document.getElementById('debugLogs');
        debugLogs.innerHTML = `
            <div class="log-entry log-info">
                <span class="log-time">[Diagnostic]</span> Simulation de transaction...
            </div>
        `;
        
        try {
            const tokenSymbol = document.getElementById('flashloan-token').value;
            const tokenAddress = TOKENS[tokenSymbol];
            const amountInput = document.getElementById('flashloan-amount').value || '1000';
            const amount = convertAmount(amountInput, tokenSymbol);
            
            debugLogs.innerHTML += `
                <div class="log-entry log-info">
                    <span class="log-time">[Params]</span> Token: ${tokenSymbol} (${tokenAddress})
                </div>
                <div class="log-entry log-info">
                    <span class="log-time">[Params]</span> Montant: ${amountInput} (converti: ${amount})
                </div>
            `;
            
            // Simuler un appel à la méthode
            try {
                await contract.methods.forceExecuteFlashLoan(tokenAddress, amount).call({from: userAccount});
                debugLogs.innerHTML += `
                    <div class="log-entry log-success">
                        <span class="log-time">[Simulation]</span> Simulation réussie! La transaction devrait fonctionner.
                    </div>
                `;
            } catch (simulationError) {
                let errorMessage = simulationError.message;
                
                debugLogs.innerHTML += `
                    <div class="log-entry log-error">
                        <span class="log-time">[Simulation]</span> La transaction échouerait.
                    </div>
                    <div class="log-entry log-error">
                        <span class="log-time">[Erreur]</span> ${errorMessage}
                    </div>
                `;
                
                // Suggestions pour résoudre le problème
                if (errorMessage.includes("gas required exceeds")) {
                    debugLogs.innerHTML += `
                        <div class="log-entry log-warning">
                            <span class="log-time">[Solution]</span> Augmentez la limite de gaz.
                        </div>
                    `;
                } else if (errorMessage.includes("revert")) {
                    debugLogs.innerHTML += `
                        <div class="log-entry log-warning">
                            <span class="log-time">[Solution]</span> Vérifiez les paramètres ou l'état du contrat.
                        </div>
                    `;
                }
            }
        } catch (error) {
            debugLogs.innerHTML += `
                <div class="log-entry log-error">
                    <span class="log-time">[Erreur]</span> ${error.message}
                </div>
            `;
        }
    });
});
</script>
</body>
</html>
/* Styles CSS à ajouter dans la section <head> du HTML */
    <style>
        :root {
            --dark-bg: #0a0a0a;
            --panel-bg: #121212;
            --green-primary: #00c853;
            --green-secondary: #00e676;
            --green-dark: #009624;
            --text-light: #e0e0e0;
            --text-dim: #9e9e9e;
            --error-color: #f44336;
            --warning-color: #ff9800;
            --info-color: #2196f3;
            --success-color: var(--green-secondary);
        }
        
        body {
            font-family: 'Roboto', Arial, sans-serif;
            background-color: var(--dark-bg);
            color: var(--text-light);
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--green-dark);
            margin-bottom: 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
        }
        
        .logo h1 {
            color: var(--green-primary);
            margin: 0;
            font-size: 28px;
        }
        
        .logo-icon {
            width: 40px;
            height: 40px;
            background-color: var(--green-primary);
            border-radius: 8px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-icon::before {
            content: "M";
            color: var(--dark-bg);
            font-weight: bold;
            font-size: 24px;
        }
        
        .wallet-info {
            display: flex;
            align-items: center;
            background-color: var(--panel-bg);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--green-dark);
        }
        
        .connect-btn {
            background-color: var(--green-primary);
            color: black;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .connect-btn:hover {
            background-color: var(--green-secondary);
        }
        
        .connect-btn:disabled {
            background-color: var(--text-dim);
            cursor: not-allowed;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--green-dark);
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 12px 20px;
            cursor: pointer;
            color: var(--text-dim);
            position: relative;
            transition: color 0.3s;
        }
        
        .tab.active {
            color: var(--green-primary);
        }
        
        .tab.active::after {
            content: "";
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: var(--green-primary);
        }
        
        .tab:hover {
            color: var(--text-light);
        }
        
        .panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #232323;
        }
        
        .panel h2 {
            color: var(--green-primary);
            margin-top: 0;
            font-size: 20px;
            border-bottom: 1px solid #232323;
            padding-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .form-control {
            margin-bottom: 15px;
            flex: 1;
            min-width: 120px;
        }
        
        .form-control label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-dim);
        }
        
        .form-control input,
        .form-control select {
            width: 100%;
            padding: 10px;
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
            color: var(--text-light);
        }
        
        .form-control input:focus,
        .form-control select:focus {
            border-color: var(--green-primary);
            outline: none;
        }
        
        .action-button {
            background-color: var(--green-dark);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: background-color 0.3s;
        }
        
        .action-button:hover {
            background-color: var(--green-primary);
        }
        
        .action-button:disabled {
            background-color: #333;
            cursor: not-allowed;
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #232323;
        }
        
        .card-title {
            color: var(--text-dim);
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .card-value {
            color: var(--text-light);
            font-size: 24px;
            font-weight: bold;
            margin: 0;
        }
        
        .card-footer {
            color: var(--text-dim);
            font-size: 12px;
            margin-top: 10px;
        }
        
        .card-positive {
            color: var(--green-primary);
        }
        
        .card-negative {
            color: var(--error-color);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-active {
            background-color: var(--green-primary);
        }
        
        .status-inactive {
            background-color: var(--error-color);
        }
        
        .logs-container {
            background-color: #0d0d0d;
            border-radius: 8px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            margin-top: 10px;
        }
        
        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #1a1a1a;
            font-size: 14px;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-time {
            color: var(--text-dim);
            margin-right: 10px;
        }
        
        .log-info {
            color: var(--info-color);
        }
        
        .log-success {
            color: var(--success-color);
        }
        
        .log-warning {
            color: var(--warning-color);
        }
        
        .log-error {
            color: var(--error-color);
        }
        
        .chart-container {
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            margin-bottom: 20px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--green-primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #232323;
        }
        
        .settings-row:last-child {
            border-bottom: none;
        }
        
        .settings-label {
            display: flex;
            flex-direction: column;
        }
        
        .settings-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .settings-description {
            color: var(--text-dim);
            font-size: 12px;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--panel-bg);
            color: var(--text-light);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--green-primary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: 300px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out forwards;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .notification-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .notification-close {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-dim);
        }
        
        .hidden {
            display: none;
        }
        
        /* Tableau des transactions */
        .transactions-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .transactions-table th {
            background-color: #1a1a1a;
            padding: 10px;
            text-align: left;
            color: var(--text-dim);
        }
        
        .transactions-table td {
            padding: 10px;
            border-bottom: 1px solid #232323;
        }
        
        .transactions-table tr:last-child td {
            border-bottom: none;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .card-grid {
                grid-template-columns: 1fr;
            }
            
            .form-row {
                flex-direction: column;
            }
            
            .header {
                flex-direction: column;
                gap: 10px;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                padding: 8px 12px;
                font-size: 14px;
            }
        }
        
        /* Pour les animations de chargement */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 200, 83, 0.3);
            border-radius: 50%;
            border-top-color: var(--green-primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Confirmation modales */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .modal {
            background-color: var(--panel-bg);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .modal-title {
            color: var(--green-primary);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
            border-bottom: 1px solid #232323;
            padding-bottom: 10px;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
    </style>
    <!-- Script de Configuration et Connexion - À placer juste avant la fermeture de </body> -->
<script>
    // =========================================
    // CONFIGURATION ET VARIABLES GLOBALES
    // =========================================
    
    // Adresse du contrat intelligent MaxBot
    const CONTRACT_ADDRESS = '0xb6e34063afc9072d76353135918f2cb11a2e54a7';
    
    // Adresses des tokens sur Polygon
    const TOKENS = {
        USDC: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
        WMATIC: '0x0d500B1D8E8E53de6Ec5cB567F8Eff95819347C0',
        WETH: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',
        WBTC: '0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6',
        DAI: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063'
    };
    
    // Décimales pour chaque token
    const TOKEN_DECIMALS = {
        USDC: 6,
        WMATIC: 18,
        WETH: 18,
        WBTC: 8,
        DAI: 18
    };
    
    // Limites de sécurité par défaut
    const SAFETY_LIMITS = {
        minAmounts: {
            USDC: 0.1,    // Minimum 0.1 USDC
            WMATIC: 0.01, // Minimum 0.01 WMATIC
            WETH: 0.0001, // Minimum 0.0001 WETH
            WBTC: 0.00001 // Minimum 0.00001 WBTC
        },
        maxAmounts: {
            USDC: 100000,  // Maximum 100,000 USDC
            WMATIC: 10000, // Maximum 10,000 WMATIC
            WETH: 10,      // Maximum 10 WETH
            WBTC: 1        // Maximum 1 WBTC
        }
    };
    
    // ABI minimal du contrat - uniquement les fonctions essentielles
    const CONTRACT_ABI = [
    // Fonction pour forcer l'exécution d'un flash loan
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "asset",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "name": "forceExecuteFlashLoan",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour exécuter directement un trade WMATIC
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "name": "directExecuteWMATICTrade",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour vérifier si le contrat est opérationnel
    {
        "inputs": [],
        "name": "isOperational",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Fonction pour vérifier les opportunités d'arbitrage
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "tokenA",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "tokenB",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            }
        ],
        "name": "checkArbitrageOpportunity",
        "outputs": [
            {
                "internalType": "bool",
                "name": "isProfitable",
                "type": "bool"
            },
            {
                "internalType": "uint256",
                "name": "profit",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Fonction pour retrait d'urgence
    {
        "inputs": [],
        "name": "emergencyWithdraw",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour exécuter un arbitrage multi-hop
    {
        "inputs": [
            {
                "internalType": "address[]",
                "name": "path",
                "type": "address[]"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            }
        ],
        "name": "executeMultiHopArbitrage",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Ajoutez ces définitions à votre CONTRACT_ABI existant
{
    "inputs": [],
    "name": "getScannerResults",
    "outputs": [
        {
            "components": [
                {
                    "internalType": "uint256",
                    "name": "timestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "address[]",
                    "name": "tokens",
                    "type": "address[]"
                },
                {
                    "internalType": "uint256",
                    "name": "profitEstimate",
                    "type": "uint256"
                },
                {
                    "internalType": "uint8",
                    "name": "confidence",
                    "type": "uint8"
                }
            ],
            "internalType": "struct IScannerService.Opportunity[]",
            "name": "",
            "type": "tuple[]"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "getMLPerformance",
    "outputs": [
        {
            "internalType": "uint8",
            "name": "performanceImprovement",
            "type": "uint8"
        },
        {
            "internalType": "uint256",
            "name": "lastUpdate",
            "type": "uint256"
        },
        {
            "internalType": "uint256",
            "name": "episodeCount",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "resetMLOptimizer",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
},
{
    "inputs": [
        {
            "internalType": "bool",
            "name": "enabled",
            "type": "bool"
        }
    ],
    "name": "setAutomationEnabled",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
},

    // Fonction pour vérifier les opportunités de flash loan
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "asset",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "name": "checkFlashLoanOpportunity",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            },
            {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Fonction pour vérifier les opportunités de liquidation
    {
        "inputs": [],
        "name": "checkLiquidationOpportunities",
        "outputs": [
            {
                "components": [
                    {
                        "internalType": "address[]",
                        "name": "borrowers",
                        "type": "address[]"
                    },
                    {
                        "internalType": "address[]",
                        "name": "collateralTokens",
                        "type": "address[]"
                    },
                    {
                        "internalType": "address[]",
                        "name": "debtTokens",
                        "type": "address[]"
                    }
                ],
                "internalType": "struct IMaxBot.LiquidationOpportunities",
                "name": "",
                "type": "tuple"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Fonction pour exécuter une liquidation
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "borrower",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "collateralToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "debtToken",
                "type": "address"
            }
        ],
        "name": "executeLiquidation",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour configurer MorpheusTrader
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_trader",
                "type": "address"
            }
        ],
        "name": "setMorpheusTrader",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour configurer ScannerService
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_scanner",
                "type": "address"
            }
        ],
        "name": "setScannerService",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour configurer MLOptimizer
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_optimizer",
                "type": "address"
            }
        ],
        "name": "setMLOptimizer",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour obtenir le meilleur itinéraire
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "tokenA",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "tokenB",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "name": "getOptimalTradeRoute",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "path",
                "type": "address[]"
            },
            {
                "internalType": "address[]",
                "name": "routers",
                "type": "address[]"
            },
            {
                "internalType": "uint256",
                "name": "expectedOutput",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Fonction pour exécuter avec MorpheusTrader
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "tokenA",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "tokenB",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "maxSlippage",
                "type": "uint256"
            }
        ],
        "name": "executeWithMorpheus",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    // Fonction pour obtenir l'adresse de MorpheusTrader
    {
        "inputs": [],
        "name": "morpheusTraderAddress",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Fonction pour obtenir l'adresse de ScannerService
    {
        "inputs": [],
        "name": "scannerServiceAddress",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // Ajouter ces définitions à votre CONTRACT_ABI existant
{
    "inputs": [],
    "name": "getScannerResults",
    "outputs": [
        {
            "components": [
                {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                {"internalType": "address[]", "name": "tokens", "type": "address[]"},
                {"internalType": "uint256", "name": "profitEstimate", "type": "uint256"},
                {"internalType": "uint8", "name": "confidence", "type": "uint8"}
            ],
            "internalType": "struct IScannerService.Opportunity[]",
            "name": "",
            "type": "tuple[]"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "getMLPerformance",
    "outputs": [
        {"internalType": "uint8", "name": "performanceImprovement", "type": "uint8"},
        {"internalType": "uint256", "name": "lastUpdate", "type": "uint256"},
        {"internalType": "uint256", "name": "episodeCount", "type": "uint256"}
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "resetMLOptimizer",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
},
{
    "inputs": [{"internalType": "bool", "name": "enabled", "type": "bool"}],
    "name": "setAutomationEnabled",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
},
    // Fonction pour obtenir l'adresse de MLOptimizer
    {
        "inputs": [],
        "name": "mlOptimizerAddress",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
];

    // Variables globales pour le fonctionnement de l'application
    let web3;                  // Instance Web3.js
    let userAccount;           // Adresse du compte connecté
    let contract;              // Instance du contrat intelligent
    let isConnected = false;   // Statut de connexion
    let transactions = [];     // Historique des transactions
    let profits = [];          // Historique des profits
    let profitChart;           // Instance du graphique
    let autoCheckInterval;     // Intervalle pour les vérifications automatiques
    let isAutomationRunning = false; // État des processus automatisés
    
    // Cache des opportunités pour optimiser les performances
    const opportunityCache = {
        lastCheck: 0,
        results: {},
        maxAgeMs: 30000, // 30 secondes
        
        // Méthode pour vérifier si une paire a été vérifiée récemment
        isRecent: function(tokenA, tokenB) {
            const key = `${tokenA}_${tokenB}`;
            return this.results[key] && 
                   (Date.now() - this.results[key].timestamp < this.maxAgeMs);
        },
        
        // Obtenir du cache ou mettre à jour
        getOrUpdate: async function(tokenA, tokenB, checkFunction) {
            const key = `${tokenA}_${tokenB}`;
            
            if (this.isRecent(tokenA, tokenB)) {
                return this.results[key].data;
            }
            
            // Exécute la fonction de vérification
            const result = await checkFunction();
            
            // Met à jour le cache
            this.results[key] = {
                timestamp: Date.now(),
                data: result
            };
            
            return result;
        },
        
        // Réinitialise le cache
        clearCache: function() {
            this.results = {};
        }
    };

// =============================================
// UTILITAIRES DE CONVERSION ET VALIDATION
// =============================================

// Ajoutez ce bloc au début de votre fichier, après les définitions 
// de TOKEN_DECIMALS et SAFETY_LIMITS mais avant toute fonction qui les utilise

// Utilitaire pour vérifier l'initialisation de Web3
function ensureWeb3Ready() {
    if (!web3) {
        console.error("Web3 n'est pas initialisé!");
        addLog("Web3 n'est pas initialisé. Connexion requise.", 'error', 'all');
        showNotification("Erreur", "L'environnement blockchain n'est pas initialisé", 'error');
        return false;
    }
    return true;
}

// Utilitaire pour vérifier la connexion
function ensureConnected() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'all');
        showNotification("Non connecté", "Veuillez connecter votre portefeuille", 'error');
        return false;
    }
    return true;
}

// Convertit un montant en unités avec les décimales correctes pour le token
// Version améliorée et robuste
function convertAmount(amount, token) {
    // Vérifions d'abord que Web3 est initialisé
    if (!web3) {
        console.error("Web3 n'est pas initialisé lors de l'appel à convertAmount!");
        // Utiliser une méthode alternative ne nécessitant pas web3
        const fallbackAmount = String(Math.floor(parseFloat(amount || "1") * 1000000));
        console.warn("Utilisation d'un montant de secours:", fallbackAmount);
        return fallbackAmount;
    }
    
    // Vérifier que token est défini
    if (!token) {
        console.error("Token non spécifié dans convertAmount");
        return web3.utils.toWei('0.01', 'ether');
    }
    
    // Vérifier que TOKEN_DECIMALS est accessible
    if (!TOKEN_DECIMALS) {
        console.error("TOKEN_DECIMALS n'est pas défini");
        return web3.utils.toWei('0.01', 'ether');
    }
    
    // Obtenir les décimales avec une valeur par défaut
    const decimals = (TOKEN_DECIMALS[token] !== undefined) ? TOKEN_DECIMALS[token] : 18;
    
    try {
        // Normaliser le montant (accepter des strings ou des nombres)
        const amountStr = String(amount || "1").replace(',', '.');
        const amountFloat = parseFloat(amountStr);
        
        if (isNaN(amountFloat)) {
            console.error(`Montant invalide: ${amount}`);
            return web3.utils.toWei('0.01', 'ether');
        }
        
        if (decimals === 6) {
            // Pour USDC et tokens avec 6 décimales
            return web3.utils.toBN(Math.floor(amountFloat * 1000000)).toString();
        } else if (decimals === 8) {
            // Pour WBTC et tokens avec 8 décimales
            return web3.utils.toBN(Math.floor(amountFloat * 100000000)).toString();
        } else {
            // Pour les tokens avec 18 décimales (ETH, MATIC, etc.)
            return web3.utils.toWei(amountStr, 'ether');
        }
    } catch (error) {
        console.error('Erreur de conversion de montant:', error, 'pour token:', token, 'montant:', amount);
        // Retourne une valeur par défaut en cas d'erreur
        return web3.utils.toWei('0.01', 'ether');
    }
}

// Formatage d'un montant pour l'affichage avec les décimales correctes
function formatAmount(amount, token) {
    // Vérifications similaires à convertAmount
    if (!web3) {
        console.error("Web3 n'est pas initialisé lors de l'appel à formatAmount!");
        return String(amount || "0");
    }
    
    if (!token || !TOKEN_DECIMALS) {
        return String(amount || "0");
    }
    
    const decimals = (TOKEN_DECIMALS[token] !== undefined) ? TOKEN_DECIMALS[token] : 18;
    
    try {
        if (decimals === 6) {
            return (parseFloat(amount) / 1000000).toFixed(6);
        } else if (decimals === 8) {
            return (parseFloat(amount) / 100000000).toFixed(8);
        } else {
            return web3.utils.fromWei(String(amount), 'ether');
        }
    } catch (error) {
        console.error('Erreur de formatage de montant:', error, 'pour token:', token, 'montant:', amount);
        return '0';
    }
}

// Valide les limites de sécurité pour une transaction
function validateTransaction(amount, token) {
    // Vérifications de base
    if (!amount || !token) {
        return { 
            valid: false, 
            message: 'Montant ou token non spécifié' 
        };
    }
    
    // Si les limites de sécurité sont désactivées, retourne toujours valide
    if (document.getElementById('safety-limits') && !document.getElementById('safety-limits').checked) {
        return { valid: true };
    }
    
    // Vérifier que SAFETY_LIMITS est accessible
    if (!SAFETY_LIMITS || !SAFETY_LIMITS.minAmounts || !SAFETY_LIMITS.maxAmounts) {
        console.error("SAFETY_LIMITS n'est pas correctement défini");
        return { valid: true }; // On suppose que c'est valide en cas de doute
    }
    
    try {
        const amountNum = parseFloat(String(amount).replace(',', '.'));
        
        // Vérifie que le montant est un nombre valide
        if (isNaN(amountNum)) {
            return { 
                valid: false, 
                message: 'Le montant n\'est pas un nombre valide' 
            };
        }
        
        // Vérifie que le token est supporté
        if (!SAFETY_LIMITS.minAmounts[token] || !SAFETY_LIMITS.maxAmounts[token]) {
            console.warn(`Limites non définies pour le token ${token}`);
            return { valid: true }; // On suppose que c'est valide
        }
        
        // Vérifie le montant minimum
        if (amountNum < SAFETY_LIMITS.minAmounts[token]) {
            return {
                valid: false,
                message: `Le montant minimum pour ${token} est ${SAFETY_LIMITS.minAmounts[token]}`
            };
        }
        
        // Vérifie le montant maximum
        if (amountNum > SAFETY_LIMITS.maxAmounts[token]) {
            return {
                valid: false,
                message: `Le montant maximum pour ${token} est ${SAFETY_LIMITS.maxAmounts[token]}`
            };
        }
        
        return { valid: true };
    } catch (error) {
        console.error('Erreur lors de la validation de la transaction:', error);
        return { 
            valid: false, 
            message: 'Erreur de validation: ' + error.message 
        };
    }
}

// Rendre ces fonctions disponibles globalement
window.convertAmount = convertAmount;
window.formatAmount = formatAmount;
window.validateTransaction = validateTransaction;
window.ensureWeb3Ready = ensureWeb3Ready;
window.ensureConnected = ensureConnected;

    // =========================================
    // INITIALISATION DE L'APPLICATION
    // =========================================
    
    // Fonction exécutée au chargement de la page
    document.addEventListener('DOMContentLoaded', function() {
        // Au tout début de l'initialisation
if (typeof window.ethereum !== 'undefined') {
    // Pré-initialiser Web3 même sans connexion
    web3 = new Web3(window.ethereum);
    console.log("Web3 pré-initialisé");
}
        console.log('MaxBot Professional Interface - Initialisation...');
        
        // Initialise les onglets de navigation
        setupTabs();
        
        // Configure les écouteurs d'événements pour les boutons
        setupEventListeners();
        
        // Initialise le graphique de profit
        setupProfitChart();
        
        // Affiche les logs initiaux
        addLog('Interface chargée. Connectez votre wallet pour commencer.', 'info', 'all');
        
        // Tente de restaurer les données depuis le stockage local
        restoreFromLocalStorage();
        
        // Vérifie automatiquement si MetaMask est déjà connecté
        checkIfConnected();
    });
    // Ajouter un bouton pour récupérer les profits
const profitBtn = document.createElement('button');
profitBtn.id = 'recoverProfitsBtn';
profitBtn.className = 'action-button';
profitBtn.textContent = 'Récupérer les profits';
profitBtn.style.backgroundColor = '#4CAF50';
profitBtn.style.color = 'white';
profitBtn.addEventListener('click', async () => {
    try {
        if (!isConnected) {
            showNotification('Non connecté', 'Veuillez vous connecter d\'abord', 'error');
            return;
        }
        
        // Utiliser emergencyWithdraw pour récupérer les profits
        const tx = await contract.methods.emergencyWithdraw().send({
            from: userAccount,
            gas: 300000
        });
        
        addLog(`Récupération des profits réussie! Hash: ${tx.transactionHash}`, 'success', 'all');
        showNotification('Succès', 'Profits récupérés avec succès', 'success');
    } catch (error) {
        addLog(`Erreur: ${error.message}`, 'error', 'all');
        showNotification('Erreur', error.message, 'error');
    }
});

// Ajouter à l'interface
const dashboardPanel = document.querySelector('#dashboard-content .panel');
if (dashboardPanel) {
    dashboardPanel.appendChild(profitBtn);
}
    
    // Configuration des onglets
    function setupTabs() {
        const tabs = document.querySelectorAll('.tab');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Supprime la classe active de tous les onglets
                tabs.forEach(t => t.classList.remove('active'));
                
                // Ajoute la classe active à l'onglet sélectionné
                tab.classList.add('active');
                
                // Masque tous les contenus d'onglet
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Affiche le contenu de l'onglet sélectionné
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(`${tabId}-content`).classList.add('active');
            });
        });
    }
    
    // Configuration des écouteurs d'événements
    function setupEventListeners() {
        // Bouton de connexion
        document.getElementById('connectBtn').addEventListener('click', connectWallet);
        
        // Boutons Flash Loans
        document.getElementById('forceExecuteFlashloanBtn').addEventListener('click', executeFlashLoan);
        document.getElementById('checkFlashloanOpportunityBtn').addEventListener('click', checkFlashLoanOpportunity);
        
        // Boutons Arbitrage
        document.getElementById('checkArbitrageBtn').addEventListener('click', checkArbitrageOpportunity);
        document.getElementById('executeArbitrageBtn').addEventListener('click', executeArbitrage);
        
        // Boutons Liquidations
        document.getElementById('startLiquidationScanBtn').addEventListener('click', startLiquidationScan);
        document.getElementById('stopLiquidationScanBtn').addEventListener('click', stopLiquidationScan);
        
        // Interrupteurs d'automatisation
        document.getElementById('flashloan-auto-mode').addEventListener('change', toggleFlashLoanAutomation);
        document.getElementById('arbitrage-auto-mode').addEventListener('change', toggleArbitrageAutomation);
        document.getElementById('liquidation-auto-mode').addEventListener('change', toggleLiquidationAutomation);
        
        // Paramètres
        document.getElementById('contract-address').addEventListener('change', updateContractAddress);
        document.getElementById('safety-limits').addEventListener('change', toggleSafetyLimits);
    }
    
    // Initialisation du graphique de profit
    function setupProfitChart() {
        const ctx = document.getElementById('profitChart').getContext('2d');
        
        profitChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Profit (MATIC)',
                    data: [],
                    borderColor: '#00c853',
                    backgroundColor: 'rgba(0, 200, 83, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#9e9e9e'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#9e9e9e'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#e0e0e0'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                }
            }
        });
    }
    
    // =========================================
    // CONNEXION BLOCKCHAIN
    // =========================================
    
    // Vérifie si MetaMask est déjà connecté
    
async function checkIfConnected() {
    console.log('Vérification de la connexion MetaMask...');
    
    if (typeof window.ethereum === 'undefined') {
        console.log('MetaMask non détecté');
        // Ajouter un message dans l'interface pour indiquer que MetaMask est nécessaire
        addLog('MetaMask n\'est pas installé. Veuillez installer l\'extension.', 'error', 'all');
        return false;
    }
    
    try {
        // Récupère les comptes déjà connectés
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        
        if (accounts.length > 0) {
            console.log('Compte déjà connecté:', accounts[0]);
            userAccount = accounts[0];
            const connected = await setupWeb3Connection();
            return connected;
        } else {
            console.log('Aucun compte connecté');
            // Essayer de restaurer la session depuis le stockage local
            const savedAccount = localStorage.getItem('maxbot_connected_account');
            if (savedAccount) {
                addLog('Tentative de reconnexion avec le compte précédent...', 'info', 'all');
                try {
                    // Demander explicitement la connexion avec le dernier compte connu
                    await window.ethereum.request({ 
                        method: 'eth_requestAccounts'
                    });
                    return await checkIfConnected(); // Vérifier à nouveau après la tentative
                } catch (requestError) {
                    console.log('Reconnexion automatique échouée:', requestError);
                    return false;
                }
            }
            return false;
        }
    } catch (error) {
        console.error('Erreur lors de la vérification de connexion:', error);
        addLog(`Erreur de vérification: ${error.message}`, 'error', 'all');
        return false;
    }
}
    
    // Connexion à MetaMask
// Dans votre fichier principal ou dans un nouveau fichier wallet-fix.js
async function connectWallet() {
    if (typeof window.ethereum === 'undefined') {
        addLog('MetaMask non détecté. Veuillez installer MetaMask.', 'error', 'all');
        return;
    }
    
    try {
        // Demander la connexion à l'utilisateur
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        userAccount = accounts[0];
        
        // Initialiser Web3
        window.web3 = new Web3(window.ethereum);
        
        // IMPORTANT: Initialiser correctement le contrat
        const contractAddress = document.getElementById('contract-address').value;
        window.contract = new window.web3.eth.Contract(CONTRACT_ABI, contractAddress);
        
        // Marquer comme connecté
        isConnected = true;
        
        // Mettre à jour l'interface
        document.getElementById('walletContainer').innerHTML = `
            <div style="display: flex; flex-direction: column;">
                <div style="display: flex; align-items: center;">
                    <div class="status-indicator status-active"></div>
                    <span style="margin-left: 5px;">${shortenAddress(userAccount)}</span>
                </div>
                <div style="font-size: 12px; color: var(--text-dim); margin-top: 5px;">
                    Connecté
                </div>
            </div>
        `;
        
        // Activer les boutons
        document.querySelectorAll('.action-button').forEach(button => {
            button.disabled = false;
        });
        
        addLog(`Connecté avec succès: ${shortenAddress(userAccount)}`, 'success', 'all');
    } catch (error) {
        console.error('Erreur lors de la connexion:', error);
        addLog(`Erreur de connexion: ${error.message}`, 'error', 'all');
    }
}
    
    // Configuration de Web3 et initialisation du contrat
    async function setupWeb3Connection() {
    try {
        // Initialise Web3 avec le provider MetaMask
        window.web3 = new Web3(window.ethereum);
        
        // Vérifie le réseau actuel
        const chainId = await web3.eth.getChainId();
        console.log('Réseau connecté ID:', chainId);
        
        // Si nous ne sommes pas sur Polygon (ID 137)
        if (chainId !== 137) {
            addLog('Réseau incorrect. Tentative de changement vers Polygon Mainnet...', 'warning', 'all');
            
            try {
                // Tente de changer vers le réseau Polygon
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x89' }], // 137 en hexadécimal
                });
                
                // Vérifie que le changement a bien eu lieu
                const newChainId = await web3.eth.getChainId();
                if (newChainId !== 137) {
                    throw new Error('Impossible de passer au réseau Polygon');
                }
            } catch (switchError) {
                // Si le réseau n'est pas configuré dans MetaMask
                if (switchError.code === 4902) {
                    try {
                        // Ajoute le réseau Polygon à MetaMask
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: '0x89',
                                chainName: 'Polygon Mainnet',
                                nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
                                rpcUrls: ['https://polygon-rpc.com'],
                                blockExplorerUrls: ['https://polygonscan.com/']
                            }],
                        });
                        
                        // On attend un peu pour que le changement se fasse
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        // Vérifie à nouveau
                        const finalChainId = await web3.eth.getChainId();
                        if (finalChainId !== 137) {
                            addLog('Veuillez sélectionner manuellement le réseau Polygon dans MetaMask', 'warning', 'all');
                            showNotification('Réseau incorrect', 'Veuillez sélectionner manuellement Polygon Mainnet', 'warning');
                            return false;
                        }
                    } catch (addError) {
                        addLog('Impossible d\'ajouter le réseau Polygon à MetaMask', 'error', 'all');
                        showNotification('Erreur de réseau', 'Impossible d\'ajouter Polygon à MetaMask', 'error');
                        return false;
                    }
                } else {
                    addLog(`Erreur de changement de réseau: ${switchError.message}`, 'error', 'all');
                    showNotification('Erreur de réseau', switchError.message, 'error');
                    return false;
                }
            }
        }
        
        // Récupère l'adresse du contrat depuis les paramètres
        const contractAddressInput = document.getElementById('contract-address').value;
        const contractAddress = contractAddressInput || CONTRACT_ADDRESS;
        
        // Valider l'adresse du contrat
        if (!web3.utils.isAddress(contractAddress)) {
            addLog('Adresse de contrat invalide!', 'error', 'all');
            showNotification('Erreur', 'L\'adresse du contrat est invalide', 'error');
            return false;
        }
        
        // Initialise le contrat (utilisez un try-catch séparé pour capturer spécifiquement cette erreur)
        try {
            window.contract = new web3.eth.Contract(CONTRACT_ABI, contractAddress);
            
            // Test simple pour vérifier que le contrat est accessible
            // Essayons d'appeler une fonction simple
            const code = await web3.eth.getCode(contractAddress);
            if (code === '0x' || code === '0x0') {
                throw new Error("Aucun contrat à cette adresse");
            }
            
            try {
                // Tentons d'appeler une fonction view basique comme name() ou balanceOf()
                const balance = await contract.methods.balanceOf(userAccount).call();
                addLog(`Contrat accessible, balance: ${web3.utils.fromWei(balance, 'ether')}`, 'success', 'all');
            } catch (viewError) {
                // Si ça échoue, essayons une autre approche
                addLog(`Note: Impossible de lire la balance, mais le contrat existe`, 'info', 'all');
            }
        } catch (contractError) {
            addLog(`Erreur d'initialisation du contrat: ${contractError.message}`, 'error', 'all');
            showNotification('Erreur de contrat', 'Impossible d\'initialiser le contrat. Vérifiez l\'adresse.', 'error');
            console.error('Erreur d\'initialisation du contrat:', contractError);
            return false;
        }
        
        // Récupère le solde du compte
        const balance = await web3.eth.getBalance(userAccount);
        const maticBalance = web3.utils.fromWei(balance, 'ether');
        
        // Met à jour l'interface
        window.isConnected = true;
        updateInterfaceAfterConnection(userAccount, maticBalance, chainId);
        
        // Configurer les écouteurs d'événements
        setupMetaMaskListeners();
        
        // Sauvegarder dans le stockage local
        localStorage.setItem('maxbot_connected_account', userAccount);
        localStorage.setItem('maxbot_contract_address', contractAddress);
        
        addLog('Connexion réussie à Polygon!', 'success', 'all');
        
        return true;
    } catch (error) {
        console.error('Erreur lors de la configuration de Web3:', error);
        addLog(`Erreur de configuration: ${error.message}`, 'error', 'all');
        showNotification('Erreur', 'Impossible de configurer la connexion blockchain', 'error');
        return false;
    }
}
    
    // Met à jour l'interface après une connexion réussie
    function updateInterfaceAfterConnection(account, balance, chainId) {
        // Met à jour l'affichage du wallet
        document.getElementById('walletContainer').innerHTML = `
            <div style="display: flex; flex-direction: column;">
                <div style="display: flex; align-items: center;">
                    <div class="status-indicator status-active"></div>
                    <span style="margin-left: 5px;">${shortenAddress(account)}</span>
                </div>
                <div style="font-size: 12px; color: var(--text-dim); margin-top: 5px;">
                    ${parseFloat(balance).toFixed(4)} MATIC
                </div>
            </div>
        `;
        
        // Met à jour l'information du réseau
        document.getElementById('networkInfo').textContent = `Polygon Mainnet (ID: ${chainId})`;
        
        // Active tous les boutons d'action
        document.querySelectorAll('.action-button').forEach(button => {
            button.disabled = false;
        });
        
        // Active tous les interrupteurs
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.disabled = false;
        });
        
        // Active tous les champs
        document.querySelectorAll('input[type="text"], input[type="number"], select').forEach(input => {
            input.disabled = false;
        });
        
        // Met à jour le statut du bot
        updateBotStatus(true);
        
        // Log et notification
        addLog(`Connecté avec succès: ${shortenAddress(account)}`, 'success', 'all');
        showNotification('Connexion réussie', 'Votre portefeuille est maintenant connecté à MaxBot', 'success');
    }
    
    // Configure les écouteurs d'événements MetaMask
    function setupMetaMaskListeners() {
        // Écouteur pour les changements de compte
        window.ethereum.on('accountsChanged', (accounts) => {
            addLog('Changement de compte détecté, rechargement...', 'info', 'all');
            showNotification('Compte changé', 'Rechargement de l\'application...', 'info');
            
            // Sauvegarde des données avant rechargement
            saveToLocalStorage();
            
            setTimeout(() => window.location.reload(), 1000);
        });
        
        // Écouteur pour les changements de réseau
        window.ethereum.on('chainChanged', (chainId) => {
            addLog('Changement de réseau détecté, rechargement...', 'info', 'all');
            showNotification('Réseau changé', 'Rechargement de l\'application...', 'info');
            
            // Sauvegarde des données avant rechargement
            saveToLocalStorage();
            
            setTimeout(() => window.location.reload(), 1000);
        });
    }
    // Configure les écouteurs d'événements du contrat
function setupContractEventListeners() {
    if (!web3 || !contract || !isConnected) {
        console.log('Impossible de configurer les écouteurs d\'événements: Web3 ou contrat non initialisé');
        return;
    }
    
    try {
        console.log('Configuration des écouteurs d\'événements du contrat...');
        
        // Arrêter les écouteurs précédents si existants
        if (window.eventSubscriptions) {
            window.eventSubscriptions.forEach(subscription => {
                if (subscription && subscription.unsubscribe) {
                    subscription.unsubscribe();
                }
            });
        }
        
        window.eventSubscriptions = [];
        
        // Définir un ABI minimal pour les événements les plus courants
        const eventABI = [
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "profit",
                        "type": "uint256"
                    }
                ],
                "name": "FlashLoanExecuted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenA",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenB",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "profit",
                        "type": "uint256"
                    }
                ],
                "name": "ArbitrageExecuted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "collateralToken",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "debtToken",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "collateralAmount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "debtAmount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "profit",
                        "type": "uint256"
                    }
                ],
                "name": "LiquidationExecuted",
                "type": "event"
            }
        ];
        
        // Configurer l'écouteur d'événements pour FlashLoanExecuted
        try {
            const flashLoanEvent = web3.utils.sha3('FlashLoanExecuted(address,uint256,uint256)');
            const flashLoanSubscription = web3.eth.subscribe('logs', {
                address: contract.options.address,
                topics: [flashLoanEvent]
            }, function(error, result) {
                if (error) {
                    console.error("Erreur d'événement FlashLoan:", error);
                    return;
                }
                processFlashLoanEvent(result);
            });
            
            window.eventSubscriptions.push(flashLoanSubscription);
            console.log('Écouteur d\'événements FlashLoanExecuted configuré');
        } catch (error) {
            console.error('Erreur lors de la configuration de l\'écouteur FlashLoan:', error);
        }
        
        // Configurer l'écouteur d'événements pour ArbitrageExecuted
        try {
            const arbitrageEvent = web3.utils.sha3('ArbitrageExecuted(address,address,uint256,uint256)');
            const arbitrageSubscription = web3.eth.subscribe('logs', {
                address: contract.options.address,
                topics: [arbitrageEvent]
            }, function(error, result) {
                if (error) {
                    console.error("Erreur d'événement Arbitrage:", error);
                    return;
                }
                processArbitrageEvent(result);
            });
            
            window.eventSubscriptions.push(arbitrageSubscription);
            console.log('Écouteur d\'événements ArbitrageExecuted configuré');
        } catch (error) {
            console.error('Erreur lors de la configuration de l\'écouteur Arbitrage:', error);
        }
        
        // Configurer l'écouteur d'événements pour LiquidationExecuted
        try {
            const liquidationEvent = web3.utils.sha3('LiquidationExecuted(address,address,uint256,uint256,uint256)');
            const liquidationSubscription = web3.eth.subscribe('logs', {
                address: contract.options.address,
                topics: [liquidationEvent]
            }, function(error, result) {
                if (error) {
                    console.error("Erreur d'événement Liquidation:", error);
                    return;
                }
                processLiquidationEvent(result);
            });
            
            window.eventSubscriptions.push(liquidationSubscription);
            console.log('Écouteur d\'événements LiquidationExecuted configuré');
        } catch (error) {
            console.error('Erreur lors de la configuration de l\'écouteur Liquidation:', error);
        }
        
        addLog('Écouteurs d\'événements configurés', 'info', 'all');
        
    } catch (error) {
        console.error('Erreur lors de la configuration des écouteurs d\'événements:', error);
        addLog('Erreur lors de la configuration des écouteurs d\'événements', 'error', 'all');
    }
}

// Traite un événement FlashLoanExecuted
function processFlashLoanEvent(log) {
    try {
        console.log('Événement FlashLoanExecuted détecté:', log);
        
        // Décoder les données de l'événement
        const decodedLog = web3.eth.abi.decodeLog(
            [
                {
                    "indexed": true,
                    "name": "token",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "name": "amount",
                    "type": "uint256"
                },
                {
                    "indexed": false,
                    "name": "profit",
                    "type": "uint256"
                }
            ],
            log.data,
            log.topics.slice(1) // Le premier élément est la signature de l'événement
        );
        
        // Trouver le symbole du token
        const tokenAddress = decodedLog.token;
        let tokenSymbol = "TOKEN";
        
        for (const [symbol, address] of Object.entries(TOKENS)) {
            if (address.toLowerCase() === tokenAddress.toLowerCase()) {
                tokenSymbol = symbol;
                break;
            }
        }
        
        // Extraire le montant et le profit
        const amount = formatAmount(decodedLog.amount, tokenSymbol);
        const profit = web3.utils.fromWei(decodedLog.profit, 'ether');
        
        // Log l'événement
        addLog(`Flash Loan exécuté: ${amount} ${tokenSymbol} avec profit de ${profit} MATIC`, 'success', 'flashloanLogs');
        
        // Enregistrer la transaction
        recordTransaction('Flash Loan', tokenSymbol, amount, profit, log.transactionHash);
        
        // Notification
        showNotification('Flash Loan exécuté', `Profit: ${profit} MATIC`, 'success');
        
    } catch (error) {
        console.error('Erreur lors du traitement de l\'événement FlashLoan:', error);
    }
}

// Traite un événement ArbitrageExecuted
function processArbitrageEvent(log) {
    try {
        console.log('Événement ArbitrageExecuted détecté:', log);
        
        // Décoder les données de l'événement
        const decodedLog = web3.eth.abi.decodeLog(
            [
                {
                    "indexed": true,
                    "name": "tokenA",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "name": "tokenB",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "indexed": false,
                    "name": "profit",
                    "type": "uint256"
                }
            ],
            log.data,
            log.topics.slice(1) // Le premier élément est la signature de l'événement
        );
        
        // Trouver les symboles des tokens
        const tokenAAddress = decodedLog.tokenA;
        const tokenBAddress = decodedLog.tokenB;
        let tokenASymbol = "TOKENA";
        let tokenBSymbol = "TOKENB";
        
        for (const [symbol, address] of Object.entries(TOKENS)) {
            if (address.toLowerCase() === tokenAAddress.toLowerCase()) {
                tokenASymbol = symbol;
            }
            if (address.toLowerCase() === tokenBAddress.toLowerCase()) {
                tokenBSymbol = symbol;
            }
        }
        
        // Extraire le montant et le profit
        const amountIn = formatAmount(decodedLog.amountIn, tokenASymbol);
        const profit = web3.utils.fromWei(decodedLog.profit, 'ether');
        
        // Log l'événement
        addLog(`Arbitrage exécuté: ${amountIn} ${tokenASymbol} vers ${tokenBSymbol} avec profit de ${profit} MATIC`, 'success', 'arbitrageLogs');
        
        // Enregistrer la transaction
        recordTransaction('Arbitrage', `${tokenASymbol}-${tokenBSymbol}`, amountIn, profit, log.transactionHash);
        
        // Notification
        showNotification('Arbitrage exécuté', `Profit: ${profit} MATIC`, 'success');
        
    } catch (error) {
        console.error('Erreur lors du traitement de l\'événement Arbitrage:', error);
    }
}

// Traite un événement LiquidationExecuted
function processLiquidationEvent(log) {
    try {
        console.log('Événement LiquidationExecuted détecté:', log);
        
        // Décoder les données de l'événement
        const decodedLog = web3.eth.abi.decodeLog(
            [
                {
                    "indexed": true,
                    "name": "collateralToken",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "name": "debtToken",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "name": "collateralAmount",
                    "type": "uint256"
                },
                {
                    "indexed": false,
                    "name": "debtAmount",
                    "type": "uint256"
                },
                {
                    "indexed": false,
                    "name": "profit",
                    "type": "uint256"
                }
            ],
            log.data,
            log.topics.slice(1) // Le premier élément est la signature de l'événement
        );
        
        // Trouver les symboles des tokens
        const collateralTokenAddress = decodedLog.collateralToken;
        const debtTokenAddress = decodedLog.debtToken;
        let collateralTokenSymbol = "COLLATERAL";
        let debtTokenSymbol = "DEBT";
        
        for (const [symbol, address] of Object.entries(TOKENS)) {
            if (address.toLowerCase() === collateralTokenAddress.toLowerCase()) {
                collateralTokenSymbol = symbol;
            }
            if (address.toLowerCase() === debtTokenAddress.toLowerCase()) {
                debtTokenSymbol = symbol;
            }
        }
        
        // Extraire les montants et le profit
        const collateralAmount = formatAmount(decodedLog.collateralAmount, collateralTokenSymbol);
        const debtAmount = formatAmount(decodedLog.debtAmount, debtTokenSymbol);
        const profit = web3.utils.fromWei(decodedLog.profit, 'ether');
        
        // Log l'événement
        addLog(`Liquidation exécutée: ${collateralAmount} ${collateralTokenSymbol} saisi pour ${debtAmount} ${debtTokenSymbol} avec profit de ${profit} MATIC`, 'success', 'liquidationLogs');
        
        // Enregistrer la transaction
        recordTransaction('Liquidation', `${collateralTokenSymbol}/${debtTokenSymbol}`, collateralAmount, profit, log.transactionHash);
        
        // Notification
        showNotification('Liquidation exécutée', `Profit: ${profit} MATIC`, 'success');
        
    } catch (error) {
        console.error('Erreur lors du traitement de l\'événement Liquidation:', error);
    }
}

// Fonction utilitaire pour obtenir le symbole d'un token à partir de son adresse
function getTokenSymbolByAddress(address) {
    if (!address) return "UNKNOWN";
    
    for (const [symbol, tokenAddress] of Object.entries(TOKENS)) {
        if (tokenAddress.toLowerCase() === address.toLowerCase()) {
            return symbol;
        }
    }
    
    return address.substring(0, 6) + "..."; // Format abrégé si non trouvé
}
    // =========================================
    // UTILITAIRES COMMUNS
    // =========================================
    
    // Raccourcit l'affichage d'une adresse Ethereum
    function shortenAddress(address) {
        return address.substring(0, 6) + '...' + address.substring(address.length - 4);
    }
    
    // Met à jour le statut du bot dans l'interface
    function updateBotStatus(isActive) {
        const statusIndicator = document.getElementById('botStatusIndicator');
        const statusText = document.getElementById('botStatusText');
        
        if (isActive) {
            statusIndicator.classList.remove('status-inactive');
            statusIndicator.classList.add('status-active');
            statusText.textContent = 'Actif';
        } else {
            statusIndicator.classList.remove('status-active');
            statusIndicator.classList.add('status-inactive');
            statusText.textContent = 'Inactif';
        }
    }

    // Fonction utilitaire pour soumettre et suivre des transactions blockchain
async function submitAndTrackTransaction(method, params, logTarget, transactionType, tokenInfo) {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', logTarget);
        return { success: false, reason: 'not_connected' };
    }
    
    addLog(`Préparation de la transaction ${transactionType}...`, 'info', logTarget);
    
    // Paramètres de base
    const gasPrice = document.getElementById('flashloan-gas-price').value || '50';
    const gasLimit = document.getElementById('flashloan-gas-limit').value || '5000000';
    
    try {
        // Log détaillé des paramètres pour le debugging
        console.log(`Transaction ${transactionType} - Paramètres:`, params);
        
        // Valider que la méthode existe
        if (!contract.methods[method]) {
            throw new Error(`La méthode ${method} n'existe pas dans le contrat.`);
        }
        
        // Estimation du gaz pour vérifier que la transaction est valide
        let estimatedGas;
        try {
            estimatedGas = await contract.methods[method](...params).estimateGas({
                from: userAccount
            });
            addLog(`Gaz estimé: ${estimatedGas} unités`, 'info', logTarget);
        } catch (gasError) {
            console.error('Erreur d\'estimation de gaz:', gasError);
            addLog(`Erreur préliminaire: ${gasError.message}`, 'error', logTarget);
            // Si l'estimation échoue, la transaction échouera probablement aussi
            throw new Error(`Erreur d'estimation de gaz: ${gasError.message}. La transaction échouerait.`);
        }
        
        // Configuration de la transaction
        const txObject = {
            from: userAccount,
            gas: Math.min(parseInt(estimatedGas * 1.3), parseInt(gasLimit)), // Ajoute 30% de marge mais limité par gasLimit
            gasPrice: web3.utils.toWei(gasPrice, 'gwei')
        };
        
        // Log de la configuration finale
        console.log(`Configuration de transaction:`, txObject);
        
        // Envoi de la transaction avec suivi de progression
        addLog(`Envoi de la transaction à la blockchain...`, 'info', logTarget);
        
        // Créer un objet de promesse personnalisé pour surveiller les étapes
        const transactionPromise = new Promise(async (resolve, reject) => {
            try {
                // Envoi initial de la transaction
                const tx = contract.methods[method](...params).send(txObject);
                
                // Écouteurs d'événements pour suivre la progression
                tx.on('transactionHash', (hash) => {
                    addLog(`🔄 Transaction envoyée! Hash: ${hash}`, 'info', logTarget);
                    addLog(`Vérifier sur Polygonscan: https://polygonscan.com/tx/${hash}`, 'info', logTarget);
                });
                
                tx.on('receipt', (receipt) => {
                    const status = receipt.status ? 'réussie' : 'échouée';
                    if (receipt.status) {
                        addLog(`✅ Transaction ${status}! Gas utilisé: ${receipt.gasUsed}`, 'success', logTarget);
                    } else {
                        addLog(`❌ Transaction ${status}! Vérifiez Polygonscan pour plus de détails.`, 'error', logTarget);
                    }
                });
                
                tx.on('error', (error) => {
                    addLog(`❌ Erreur de transaction: ${error.message}`, 'error', logTarget);
                    reject(error);
                });
                
                // Attendre la complétion de la transaction
                const receipt = await tx;
                resolve(receipt);
            } catch (error) {
                reject(error);
            }
        });
        
        // Attendre la résolution de la promesse
        const receipt = await transactionPromise;
        
        // Vérifier si la transaction a réussi
        if (!receipt.status) {
            throw new Error("La transaction a été envoyée mais a échoué à l'exécution.");
        }
        
        // Transaction réussie - Enregistrer et notifier
        addLog(`Transaction ${transactionType} réussie! Hash: ${receipt.transactionHash}`, 'success', logTarget);
        
        // Enregistrer la transaction avec les détails
        recordTransaction(transactionType, tokenInfo, '0', '0', receipt.transactionHash);
        
        // Notification
        showNotification(`${transactionType} exécuté`, 'Transaction confirmée sur la blockchain', 'success');
        
        return { 
            success: true, 
            hash: receipt.transactionHash,
            receipt: receipt
        };
    } catch (error) {
        console.error(`Erreur lors de l'exécution de ${transactionType}:`, error);
        
        // Message d'erreur détaillé et adapté
        let errorMessage = error.message;
        
        // Analyser le message d'erreur pour fournir des informations plus utiles
        if (errorMessage.includes('gas')) {
            errorMessage = "Erreur de gaz - Essayez d'augmenter la limite de gaz";
        } else if (errorMessage.includes('rejected')) {
            errorMessage = "Transaction rejetée par le portefeuille";
        } else if (errorMessage.includes('nonce')) {
            errorMessage = "Erreur de nonce - Réinitialisez votre portefeuille ou attendez la confirmation des transactions précédentes";
        } else if (errorMessage.includes('underpriced')) {
            errorMessage = "Gas price trop bas - Augmentez le prix du gaz";
        }
        
        addLog(`❌ Erreur: ${errorMessage}`, 'error', logTarget);
        showNotification('Erreur de transaction', errorMessage, 'error');
        
        return { 
            success: false, 
            error: errorMessage,
            details: error
        };
    }
}
    
    // Fonction pour vérifier la validité des transactions
async function verifyTransactions() {
    if (!isConnected || !web3) return;
    
    try {
        let invalidFound = false;
        
        for (let i = 0; i < Math.min(transactions.length, 10); i++) {  // Vérifie les 10 dernières transactions
            const tx = transactions[i];
            
            // Vérifier si la transaction existe sur la blockchain
            const receipt = await web3.eth.getTransactionReceipt(tx.hash);
            
            if (!receipt) {
                console.warn(`Transaction invalide détectée: ${tx.hash}`);
                tx.status = 'invalid';
                invalidFound = true;
                
                // Marquer la transaction comme invalide dans l'interface
                const rows = document.querySelectorAll('#transactionsTable tr');
                if (rows[i]) {
                    const statusCell = rows[i].querySelector('td:last-child');
                    if (statusCell) {
                        statusCell.innerHTML = '<span style="color: var(--error-color);">Non trouvée</span>';
                    }
                }
            }
        }
        
        if (invalidFound) {
            addLog('⚠️ Attention: Des transactions invalides ont été détectées dans l\'historique', 'warning', 'all');
            showNotification('Transactions suspectes', 'Certaines transactions n\'existent pas sur la blockchain', 'warning');
        }
        
        // Mettre à jour l'interface
        updateTransactionsTable();
    } catch (error) {
        console.error('Erreur lors de la vérification des transactions:', error);
    }
}

// Vérifier les transactions après connexion et périodiquement
document.addEventListener('DOMContentLoaded', function() {
    // Configuration existante...
    
    // Ajouter la vérification périodique des transactions
    setInterval(function() {
        if (isConnected) {
            verifyTransactions();
        }
    }, 300000); // Toutes les 5 minutes
});
    
    // Formate un montant pour l'affichage avec les décimales correctes
    function formatAmount(amount, token) {
        const decimals = TOKEN_DECIMALS[token] || 18;
        
        try {
            if (decimals === 6) {
                return (parseFloat(amount) / 1000000).toFixed(6);
            } else if (decimals === 8) {
                return (parseFloat(amount) / 100000000).toFixed(8);
            } else {
                return web3.utils.fromWei(amount.toString(), 'ether');
            }
        } catch (error) {
            console.error('Erreur de formatage de montant:', error);
            return '0';
        }
    }
    
    // Vérifie les limites de sécurité pour une transaction
    function validateTransaction(amount, token) {
        // Si les limites de sécurité sont désactivées, retourne toujours valide
        if (!document.getElementById('safety-limits').checked) {
            return { valid: true };
        }
        
        const amountNum = parseFloat(amount);
        
        // Vérifie que le montant est un nombre valide
        if (isNaN(amountNum)) {
            return { valid: false, message: 'Le montant n\'est pas un nombre valide' };
        }
        
        // Vérifie le montant minimum
        if (amountNum < SAFETY_LIMITS.minAmounts[token]) {
            return {
                valid: false,
                message: `Le montant minimum pour ${token} est ${SAFETY_LIMITS.minAmounts[token]}`
            };
        }
        
        // Vérifie le montant maximum
        if (amountNum > SAFETY_LIMITS.maxAmounts[token]) {
            return {
                valid: false,
                message: `Le montant maximum pour ${token} est ${SAFETY_LIMITS.maxAmounts[token]}`
            };
        }
        
        return { valid: true };
    }
    
    // Ajoute un log à l'interface
    function addLog(message, type = 'info', target = 'all') {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `<div class="log-entry log-${type}"><span class="log-time">[${timestamp}]</span> ${message}</div>`;
        
        if (target === 'all') {
            // Ajoute le log à tous les conteneurs
            document.getElementById('flashloanLogs').innerHTML = logEntry + document.getElementById('flashloanLogs').innerHTML;
            document.getElementById('arbitrageLogs').innerHTML = logEntry + document.getElementById('arbitrageLogs').innerHTML;
            document.getElementById('liquidationLogs').innerHTML = logEntry + document.getElementById('liquidationLogs').innerHTML;
        } else {
            // Ajoute le log au conteneur spécifique
            document.getElementById(target).innerHTML = logEntry + document.getElementById(target).innerHTML;
        }
    }
    
    // Affiche une notification
    function showNotification(title, message, type = 'info') {
        // Ne montre pas de notification si elles sont désactivées
        if (!document.getElementById('notifications-enabled').checked) {
            return;
        }
        
        // Crée l'élément de notification
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <div class="notification-close">&times;</div>
            <div class="notification-title">${title}</div>
            <div class="notification-message">${message}</div>
        `;
        
        // Ajoute la notification au document
        document.body.appendChild(notification);
        
        // Configure le bouton de fermeture
        notification.querySelector('.notification-close').addEventListener('click', () => {
            notification.remove();
        });
        
        // Supprime automatiquement la notification après 5 secondes
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 5000);
    }
    
    // Enregistre une transaction dans l'historique
    async function recordTransaction(type, token, amount, profit, hash) {
    try {
        // Vérifier que la transaction existe réellement sur la blockchain
        const receipt = await web3.eth.getTransactionReceipt(hash);
        
        if (!receipt) {
            console.error("Transaction non trouvée sur la blockchain:", hash);
            addLog(`Avertissement: Transaction non trouvée sur la blockchain`, 'warning', 'all');
            return;
        }
        
        const now = new Date();
        const transaction = {
            id: transactions.length + 1,
            type: type,
            token: token,
            amount: amount,
            profit: profit,
            timestamp: now,
            hash: hash,
            status: receipt.status ? 'success' : 'failed'
        };
        
        // Ajoute au début de la liste des transactions
        transactions.unshift(transaction);
        
        // Met à jour la table des transactions
        updateTransactionsTable();
        
        // Met à jour les données de profit
        if (receipt.status && parseFloat(profit) > 0) {
            updateProfitData(profit);
        }
        
        // Met à jour les métriques
        updateMetrics();
        
        // Sauvegarde dans le stockage local
        saveToLocalStorage();
    } catch (error) {
        console.error("Erreur lors de l'enregistrement de la transaction:", error);
        addLog(`Erreur lors de l'enregistrement de la transaction: ${error.message}`, 'error', 'all');
    }
}
    
    // Met à jour la table des transactions
    function updateTransactionsTable() {
        const table = document.getElementById('transactionsTable');
        
        if (transactions.length === 0) {
            table.innerHTML = `<tr><td colspan="6" style="text-align: center;">Aucune transaction à afficher</td></tr>`;
            return;
        }
        
        let html = '';
        
        // Limite à 10 transactions pour l'affichage
        const displayTransactions = transactions.slice(0, 10);
        
        displayTransactions.forEach(tx => {
            html += `
                <tr>
                    <td>${tx.timestamp.toLocaleString()}</td>
                    <td>${tx.type}</td>
                    <td>${tx.amount} ${tx.token}</td>
                    <td class="card-positive">${tx.profit} MATIC</td>
                    <td><a href="https://polygonscan.com/tx/${tx.hash}" target="_blank" style="color: var(--info-color);">${shortenAddress(tx.hash)}</a></td>
                    <td>${tx.status === 'success' ? '<span style="color: var(--green-primary);">Réussi</span>' : '<span style="color: var(--error-color);">Échoué</span>'}</td>
                </tr>
            `;
        });
        
        table.innerHTML = html;
    }
    
    // Met à jour les données de profit
    function updateProfitData(newProfit) {
        const now = new Date();
        
        // Ajoute le profit à l'historique
        profits.push({
            time: now,
            value: parseFloat(newProfit)
        });
        
        // Met à jour le graphique
        updateProfitChart();
    }
    
    // Met à jour le graphique de profit
    function updateProfitChart() {
        // Limite à 20 points de données
        const chartData = profits.slice(-20);
        
        // Prépare les données pour le graphique
        const labels = chartData.map(p => p.time.toLocaleTimeString());
        const data = chartData.map(p => p.value);
        
        // Met à jour le graphique
        profitChart.data.labels = labels;
        profitChart.data.datasets[0].data = data;
        profitChart.update();
    }
    
    // Met à jour les métriques affichées
    function updateMetrics() {
        // Calcule le profit total
        const totalProfit = profits.reduce((sum, p) => sum + p.value, 0);
        
        // Calcule le profit des dernières 24h
        const last24h = new Date();
        last24h.setHours(last24h.getHours() - 24);
        const profit24h = profits
            .filter(p => p.time > last24h)
            .reduce((sum, p) => sum + p.value, 0);
        
        // Met à jour l'affichage du profit total
        document.querySelector('.card-grid .card:nth-child(1) .card-value').textContent = `${totalProfit.toFixed(4)} MATIC`;
        document.querySelector('.card-grid .card:nth-child(1) .card-footer').innerHTML = `Dernières 24h: <span class="${profit24h >= 0 ? 'card-positive' : 'card-negative'}">${profit24h >= 0 ? '+' : ''}${profit24h.toFixed(4)} MATIC</span>`;
        
        // Met à jour le nombre de transactions
        document.querySelector('.card-grid .card:nth-child(2) .card-value').textContent = transactions.length;
        
        // Statistiques des transactions
        const successfulTx = transactions.filter(tx => tx.status === 'success').length;
        const failedTx = transactions.filter(tx => tx.status !== 'success').length;
        document.querySelector('.card-grid .card:nth-child(2) .card-footer').textContent = `Réussies: ${successfulTx} | Échouées: ${failedTx}`;
    }
    
    // Vérifie le statut du contrat
    async function checkContractStatus() {
  try {
    // Première méthode: essayer d'accéder comme fonction (méthode originale)
    const isOperational = await contract.methods.isOperational().call();
    console.log("État opérationnel (via fonction):", isOperational);
    return isOperational;
  } catch (error) {
    console.log("Impossible d'accéder à isOperational comme fonction, essai comme variable...");
    
    try {
      // Deuxième méthode: accéder comme variable d'état publique
      const result = await contract.methods.isOperational.call();
      console.log("Résultat brut:", result);
      
      // Si result est défini, on le considère comme true
      if (result !== undefined && result !== null) {
        console.log("État opérationnel (via variable):", true);
        return true;
      }
    } catch (secondError) {
      console.log("Impossible d'accéder à isOperational comme variable, essai d'accès direct...");
    }
    
    try {
      // Troisième méthode: accès direct au stockage
      const storage = await web3.eth.getStorageAt(contractAddress, 0);
      const isOperational = storage !== '0x0000000000000000000000000000000000000000000000000000000000000000';
      console.log("État opérationnel (via stockage direct):", isOperational);
      return isOperational;
    } catch (thirdError) {
      console.error("Toutes les méthodes de vérification ont échoué");
      
      // En dernier recours, supposer que le contrat est opérationnel pour éviter le blocage
      console.log("Par défaut, on considère que le contrat est opérationnel");
      return true;
    }
  }
}

// Ajouter cet écouteur pour gérer proprement la fermeture des connexions MetaMask
window.addEventListener('beforeunload', () => {
  // Aide à fermer proprement les connexions avec MetaMask
  if (window.ethereum && window.ethereum.removeAllListeners) {
    window.ethereum.removeAllListeners();
  }
});
// Initialiser les extensions du bot
async function initializeExtensions() {
    if (!isConnected || !contract) {
        console.log("Impossible d'initialiser les extensions sans connexion");
        return false;
    }
    
    try {
        addLog('Détection des extensions...', 'info', 'morpheusLogs');
        
        // Vérifier si les méthodes d'extensions existent
        const contractMethods = await verifyContractFunctions();
        const hasExtensions = contractMethods.some(method => 
            method.includes('Morpheus') || 
            method.includes('Scanner') || 
            method.includes('MLOptimizer')
        );
        
        if (!hasExtensions) {
            addLog('Aucune extension détectée sur ce contrat', 'info', 'morpheusLogs');
            return false;
        }
        
        // Vérifier MorpheusTrader
        if (contractMethods.includes('morpheusTraderAddress') || 
            contractMethods.includes('getMorpheusTrader')) {
            try {
                const morpheusAddress = await contract.methods.morpheusTraderAddress().call();
                if (morpheusAddress && morpheusAddress !== '0x0000000000000000000000000000000000000000') {
                    morpheusTraderAddress = morpheusAddress;
                    document.getElementById('morpheus-address').value = morpheusAddress;
                    addLog('MorpheusTrader détecté: ' + shortenAddress(morpheusAddress), 'info', 'morpheusLogs');
                    enableMorpheusControls();
                }
            } catch (error) {
                console.log('MorpheusTrader non disponible:', error.message);
            }
        }
        
        // Vérifier ScannerService
        if (contractMethods.includes('scannerServiceAddress') || 
            contractMethods.includes('getScannerService')) {
            try {
                const scannerAddress = await contract.methods.scannerServiceAddress().call();
                if (scannerAddress && scannerAddress !== '0x0000000000000000000000000000000000000000') {
                    scannerServiceAddress = scannerAddress;
                    document.getElementById('scanner-address').value = scannerAddress;
                    addLog('ScannerService détecté: ' + shortenAddress(scannerAddress), 'info', 'morpheusLogs');
                    document.getElementById('scanner-auto-mode').disabled = false;
                    document.getElementById('scanner-confidence').disabled = false;
                }
            } catch (error) {
                console.log('ScannerService non disponible:', error.message);
            }
        }
        
        // Vérifier MLOptimizer
        if (contractMethods.includes('mlOptimizerAddress') || 
            contractMethods.includes('getMLOptimizer')) {
            try {
                const mlAddress = await contract.methods.mlOptimizerAddress().call();
                if (mlAddress && mlAddress !== '0x0000000000000000000000000000000000000000') {
                    mlOptimizerAddress = mlAddress;
                    document.getElementById('ml-address').value = mlAddress;
                    addLog('MLOptimizer détecté: ' + shortenAddress(mlAddress), 'info', 'mlLogs');
                    document.getElementById('ml-auto-mode').disabled = false;
                    document.getElementById('forceMLUpdateBtn').disabled = false;
                    document.getElementById('resetMLBtn').disabled = false;
                }
            } catch (error) {
                console.log('MLOptimizer non disponible:', error.message);
            }
        }
        
        // Activer le bouton d'enregistrement des adresses
        document.getElementById('setExtensionsBtn').disabled = false;
        
        return true;
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des extensions:', error);
        addLog('Erreur d\'initialisation des extensions: ' + error.message, 'error', 'morpheusLogs');
        return false;
    }
}

// Activer les contrôles de MorpheusTrader
function enableMorpheusControls() {
    if (document.getElementById('findBestRouteBtn')) {
        document.getElementById('findBestRouteBtn').disabled = false;
    }
    if (document.getElementById('executeWithMorpheusBtn')) {
        document.getElementById('executeWithMorpheusBtn').disabled = false;
    }
}

// Détection et adaptation automatique des capacités du contrat
async function detectContractCapabilities() {
    if (!isConnected || !contract) return false;
    
    try {
        const methods = await verifyContractFunctions();
        
        // Adapter l'interface selon les méthodes disponibles
        const flashLoanSupported = methods.includes('forceExecuteFlashLoan');
        const arbitrageSupported = methods.includes('checkArbitrageOpportunity');
        const liquidationSupported = methods.includes('executeLiquidation') || methods.includes('checkLiquidations');
        
        // Mettre à jour les boutons d'action
        document.getElementById('forceExecuteFlashloanBtn').disabled = !flashLoanSupported;
        document.getElementById('checkFlashloanOpportunityBtn').disabled = !flashLoanSupported;
        document.getElementById('checkArbitrageBtn').disabled = !arbitrageSupported;
        document.getElementById('executeArbitrageBtn').disabled = !arbitrageSupported;
        
        // Ajouter des indicateurs visuels pour les fonctionnalités disponibles
        addLog(`Fonctionnalités détectées: ${methods.join(', ')}`, 'info', 'all');
        
        // Vérifier les extensions
        const hasExtensions = methods.some(m => 
            m.includes('Morpheus') || m.includes('Scanner') || 
            m.includes('MLOptimizer') || m.includes('Extensions')
        );
        
        // Mettre à jour l'interface des extensions si nécessaire
        if (document.getElementById('extensions')) {
            document.getElementById('extensions').style.display = hasExtensions ? 'block' : 'none';
        }
        
        // Retourner un résumé des capacités
        return {
            flashLoan: flashLoanSupported,
            arbitrage: arbitrageSupported,
            liquidation: liquidationSupported,
            extensions: hasExtensions,
            methods: methods
        };
    } catch (error) {
        console.error('Erreur lors de la détection des capacités:', error);
        addLog('Erreur de détection des fonctionnalités du contrat', 'error', 'all');
        return false;
    }
}

// Également, assurez-vous que vos autres fonctions qui interagissent avec MetaMask
// gèrent correctement les erreurs et les timeout. Par exemple:
async function sendTransaction(method, params) {
  try {
    // Ajouter un timeout pour éviter les connexions qui restent en suspens
    const result = await Promise.race([
      method(...params).send({ from: currentAccount }),
      new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 30000))
    ]);
    return result;
  } catch (error) {
    console.error("Erreur lors de la transaction:", error);
    // Gérer l'erreur de façon appropriée
    throw error;
  }
}
    // Vérifie les fonctions disponibles dans le contrat
    async function verifyContractFunctions() {
        if (!isConnected || !contract) {
            addLog('Veuillez d\'abord vous connecter', 'error', 'all');
            return [];
        }
        
        try {
            addLog('Vérification des fonctions du contrat...', 'info', 'all');
            
            // Récupère toutes les méthodes disponibles
            const methods = Object.keys(contract.methods).filter(m => !m.includes('0x'));
            
            console.log('Fonctions disponibles dans le contrat:', methods);
            addLog(`Fonctions disponibles: ${methods.join(', ')}`, 'info', 'all');
            
            // Liste des fonctions critiques
            const criticalFunctions = [
                'forceExecuteFlashLoan',
                'directExecuteWMATICTrade',
                'isOperational',
                'checkArbitrageOpportunity'
            ];
            
            // Vérifie la présence de chaque fonction critique
            criticalFunctions.forEach(funcName => {
                if (methods.includes(funcName)) {
                    addLog(`✅ Fonction '${funcName}' disponible`, 'success', 'all');
                } else {
                    addLog(`❌ Fonction '${funcName}' NON DISPONIBLE - Certaines fonctionnalités peuvent être limitées`, 'warning', 'all');
                }
            });
            
            return methods;
        } catch (error) {
            console.error('Erreur lors de la vérification des fonctions:', error);
            addLog(`Erreur de vérification des fonctions: ${error.message}`, 'error', 'all');
            return [];
        }
    }
    
    // Gestionnaire unifié des erreurs du contrat
    async function handleContractError(error, actionName, fallbackFunction = null) {
        console.error(`Erreur lors de ${actionName}:`, error);
        
        // Erreurs spécifiques à MetaMask
        if (error.code === 4001) {
            // Transaction refusée par l'utilisateur
            addLog('Transaction annulée par l\'utilisateur', 'warning', 'all');
            showNotification('Transaction annulée', 'Vous avez refusé la transaction', 'warning');
            return { success: false, reason: 'user_cancelled' };
        }
        
        // Erreurs liées au gaz
        if (error.message && error.message.includes('gas')) {
            addLog(`Erreur de gaz: ${error.message}. Augmentez la limite de gaz.`, 'error', 'all');
            showNotification('Erreur de gaz', 'Augmentez la limite de gaz et réessayez', 'error');
            return { success: false, reason: 'gas_error' };
        }
        
        // Erreurs de nonce
        if (error.message && error.message.includes('nonce')) {
            addLog('Erreur de nonce: transaction en attente. Vérifiez MetaMask.', 'error', 'all');
            showNotification('Erreur de transaction', 'Une transaction précédente est en attente', 'error');
            return { success: false, reason: 'nonce_error' };
        }
        
        // Fonction manquante
        if (error.message && (error.message.includes('not a function') || error.message.includes('method not found'))) {
            addLog(`La fonction n'existe pas ou n'est pas disponible. Vérification des fonctions...`, 'error', 'all');
            await verifyContractFunctions();
            
            // Si une fonction de fallback est fournie, essayer celle-ci
            if (fallbackFunction) {
                addLog(`Tentative avec une méthode alternative...`, 'info', 'all');
                try {
                    return await fallbackFunction();
                } catch (fallbackError) {
                    addLog(`Échec de la méthode alternative: ${fallbackError.message}`, 'error', 'all');
                    return { success: false, reason: 'fallback_failed' };
                }
            }
            
            return { success: false, reason: 'function_not_found' };
        }
        
        // Erreur générique
        addLog(`Erreur lors de ${actionName}: ${error.message}`, 'error', 'all');
        showNotification('Erreur', `Échec de ${actionName}: ${error.message.substring(0, 50)}...`, 'error');
        return { success: false, reason: 'unknown_error', details: error.message };
    }
    
    // Changement d'adresse de contrat
    function updateContractAddress() {
        if (!isConnected) return;
        
        const newAddress = document.getElementById('contract-address').value;
        
        // Vérifie que l'adresse est valide
        if (!web3.utils.isAddress(newAddress)) {
            showNotification('Adresse invalide', 'L\'adresse du contrat n\'est pas valide', 'error');
            return;
        }
        
        // Réinitialise le contrat avec la nouvelle adresse
        contract = new web3.eth.Contract(CONTRACT_ABI, newAddress);
        
        // Vérifie le statut du nouveau contrat
        checkContractStatus();
        
        addLog(`Adresse du contrat changée pour: ${newAddress}`, 'info', 'all');
        showNotification('Adresse changée', 'L\'adresse du contrat a été mise à jour', 'success');
    }
    
    // Active/désactive les limites de sécurité
    function toggleSafetyLimits() {
        const isEnabled = document.getElementById('safety-limits').checked;
        
        if (isEnabled) {
            addLog('Limites de sécurité activées', 'info', 'all');
            showNotification('Sécurité activée', 'Les limites de montant sont maintenant appliquées', 'info');
        } else {
            addLog('⚠️ Limites de sécurité désactivées. Soyez prudent !', 'warning', 'all');
            showNotification('Sécurité désactivée', 'Les limites de montant ne sont plus vérifiées. Soyez vigilant !', 'warning');
        }
    }
    
    // Sauvegarde les données dans le stockage local
    function saveToLocalStorage() {
        try {
            // Sauvegarde les transactions
            const transactionsToSave = transactions.map(tx => ({
                ...tx,
                timestamp: tx.timestamp.toISOString() // Convertit la date en string
            }));
            
            localStorage.setItem('maxbot_transactions', JSON.stringify(transactionsToSave));
            
            // Sauvegarde les profits
            const profitsToSave = profits.map(p => ({
                ...p,
                time: p.time.toISOString() // Convertit la date en string
            }));
            
            localStorage.setItem('maxbot_profits', JSON.stringify(profitsToSave));
            
            console.log('Données sauvegardées dans le stockage local');
        } catch (error) {
            console.error('Erreur lors de la sauvegarde des données:', error);
        }
    }
    
    // Restaure les données depuis le stockage local
    function restoreFromLocalStorage() {
        try {
            // Restaure les transactions
            const savedTransactions = localStorage.getItem('maxbot_transactions');
            if (savedTransactions) {
                transactions = JSON.parse(savedTransactions).map(tx => ({
                    ...tx,
                    timestamp: new Date(tx.timestamp) // Reconvertit le string en date
                }));
            }
            
            // Restaure les profits
            const savedProfits = localStorage.getItem('maxbot_profits');
            if (savedProfits) {
                profits = JSON.parse(savedProfits).map(p => ({
                    ...p,
                    time: new Date(p.time) // Reconvertit le string en date
                }));
            }
            
            // Met à jour l'interface si des données ont été restaurées
            if ((transactions && transactions.length > 0) || (profits && profits.length > 0)) {
                updateTransactionsTable();
                updateProfitChart();
                updateMetrics();
                console.log('Données restaurées depuis le stockage local');
            }
        } catch (error) {
            console.error('Erreur lors de la restauration des données:', error);
        }
    }
    
    // Fonctions qui seront implémentées dans la partie 4
    function executeFlashLoan() { /* Implémenté dans la partie 4 */ }
    function checkFlashLoanOpportunity() { /* Implémenté dans la partie 4 */ }
    function executeArbitrage() { /* Implémenté dans la partie 4 */ }
    function checkArbitrageOpportunity() { /* Implémenté dans la partie 4 */ }
    function startLiquidationScan() { /* Implémenté dans la partie 4 */ }
    function stopLiquidationScan() { /* Implémenté dans la partie 4 */ }
    function toggleFlashLoanAutomation() { /* Implémenté dans la partie 4 */ }
    function toggleArbitrageAutomation() { /* Implémenté dans la partie 4 */ }
    function toggleLiquidationAutomation() { /* Implémenté dans la partie 4 */ }
    </script>

    <!-- Script d'Exécution des fonctions - À placer après le script de configuration -->
<script>
    // =========================================
    // EXÉCUTION DES FLASH LOANS
    // =========================================
    
    // Exécute un flash loan
    async function executeFlashLoan() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'flashloanLogs');
        return { success: false, reason: 'not_connected' };
    }
    
    // Récupère les valeurs du formulaire
    const tokenSymbol = document.getElementById('flashloan-token').value;
    const tokenAddress = TOKENS[tokenSymbol];
    let amountInput = document.getElementById('flashloan-amount').value || '1';
    const gasPrice = document.getElementById('flashloan-gas-price').value || '50';
    const gasLimit = document.getElementById('flashloan-gas-limit').value || '3000000';
    
    // Vérifier la validité du montant
    if (parseFloat(amountInput) < 250000) {
        addLog(`Le montant fourni (${amountInput}) est inférieur au minimum requis (250000). Ajustement automatique.`, 'warning', 'flashloanLogs');
        amountInput = '250000';
        document.getElementById('flashloan-amount').value = '250000';
    }
    
    // Valide la transaction selon les limites de sécurité
    const validation = validateTransaction(amountInput, tokenSymbol);
    if (!validation.valid) {
        addLog(`Validation échouée: ${validation.message}`, 'error', 'flashloanLogs');
        showNotification('Erreur de validation', validation.message, 'error');
        return { success: false, reason: 'validation_failed', message: validation.message };
    }
    
    // Convertit le montant avec les décimales correctes
    const amount = convertAmount(amountInput, tokenSymbol);
    
    try {
        addLog(`Préparation du flash loan pour ${amountInput} ${tokenSymbol}...`, 'info', 'flashloanLogs');
        
        // Désactiver le bouton pendant la transaction
        document.getElementById('forceExecuteFlashloanBtn').disabled = true;
        
        // Estimer le gaz nécessaire
        let estimatedGas;
        try {
            estimatedGas = await contract.methods.forceExecuteFlashLoan(tokenAddress, amount).estimateGas({
                from: userAccount
            });
            estimatedGas = Math.floor(estimatedGas * 1.2); // Ajouter 20% de marge
            addLog(`Gaz estimé: ${estimatedGas} unités`, 'info', 'flashloanLogs');
        } catch (gasError) {
            console.error('Erreur d\'estimation de gaz:', gasError);
            addLog(`Erreur d'estimation de gaz: ${gasError.message}. Utilisation du gaz par défaut.`, 'warning', 'flashloanLogs');
            estimatedGas = parseInt(gasLimit);
        }
        
        // Envoyer la transaction
        addLog(`Envoi de la transaction...`, 'info', 'flashloanLogs');
        const transaction = await contract.methods.forceExecuteFlashLoan(tokenAddress, amount).send({
            from: userAccount,
            gas: estimatedGas,
            gasPrice: web3.utils.toWei(gasPrice, 'gwei')
        });
        
        // Transaction réussie
        addLog(`Transaction réussie! Hash: ${transaction.transactionHash}`, 'success', 'flashloanLogs');
        addLog(`Voir sur Polygonscan: https://polygonscan.com/tx/${transaction.transactionHash}`, 'info', 'flashloanLogs');
        
        // Enregistre la transaction
        recordTransaction('Flash Loan', tokenSymbol, amountInput, '0', transaction.transactionHash);
        
        // Notification
        showNotification('Flash Loan exécuté', 'Transaction envoyée avec succès', 'success');
        
        // Réactiver le bouton
        document.getElementById('forceExecuteFlashloanBtn').disabled = false;
        
        return { 
            success: true, 
            hash: transaction.transactionHash
        };
    } catch (error) {
        // Réactiver le bouton en cas d'erreur
        document.getElementById('forceExecuteFlashloanBtn').disabled = false;
        
        console.error('Erreur lors de l\'exécution du flash loan:', error);
        addLog(`Erreur: ${error.message}`, 'error', 'flashloanLogs');
        showNotification('Erreur', `Échec du flash loan: ${error.message.substring(0, 50)}...`, 'error');
        
        return { 
            success: false, 
            error: error.message
        };
    }
}
    
    // Vérifie l'opportunité de flash loan
    async function checkFlashLoanOpportunity() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'flashloanLogs');
        return false;
    }
    
    // Récupère les valeurs du formulaire
    const tokenSymbol = document.getElementById('flashloan-token').value;
    const tokenAddress = TOKENS[tokenSymbol];
    const amountInput = document.getElementById('flashloan-amount').value || '1';
    
    // Convertit le montant
    const amount = convertAmount(amountInput, tokenSymbol);
    
    try {
        addLog(`Vérification d'opportunité pour ${amountInput} ${tokenSymbol}...`, 'info', 'flashloanLogs');
        
        // Appeler directement la fonction de vérification du contrat
        const result = await contract.methods.checkFlashLoanOpportunity(tokenAddress, amount).call();
        
        const canExec = result[0];
        const execPayload = result[1];
        
        if (canExec) {
            addLog(`Opportunité trouvée! Flash loan possible.`, 'success', 'flashloanLogs');
            showNotification('Opportunité détectée', `Flash loan possible pour ${amountInput} ${tokenSymbol}`, 'success');
            return true;
        } else {
            addLog(`Aucune opportunité rentable trouvée pour ce montant.`, 'warning', 'flashloanLogs');
            return false;
        }
    } catch (error) {
        console.error('Erreur lors de la vérification d\'opportunité:', error);
        addLog(`Erreur: ${error.message}`, 'error', 'flashloanLogs');
        showNotification('Erreur', error.message, 'error');
        return false;
    }
}
    
    // Active/désactive l'automatisation des flash loans
    function toggleFlashLoanAutomation(event) {
        const isChecked = event.target.checked;
        
        // Met à jour les champs associés
        document.getElementById('flashloan-min-profit').disabled = !isChecked;
        document.getElementById('flashloan-check-interval').disabled = !isChecked;
        
        if (isChecked) {
            startFlashLoanAutomation();
        } else {
            stopFlashLoanAutomation();
        }
    }
    
    // Démarre l'automatisation des flash loans
    function startFlashLoanAutomation() {
        if (autoCheckInterval) {
            clearInterval(autoCheckInterval);
        }
        
        // Récupère les paramètres
        const intervalSeconds = parseInt(document.getElementById('flashloan-check-interval').value) || 30;
        const minProfit = parseFloat(document.getElementById('flashloan-min-profit').value) || 0.01;
        
        addLog(`Démarrage de l'automatisation des flash loans (intervalle: ${intervalSeconds}s, profit min: ${minProfit} MATIC)`, 'info', 'flashloanLogs');
        showNotification('Automatisation activée', 'Les flash loans seront exécutés automatiquement', 'info');
        
        // Réinitialise le cache à chaque démarrage
        opportunityCache.clearCache();
        
        // Configure l'intervalle d'automatisation
        autoCheckInterval = setInterval(async () => {
            if (!isConnected) return;
            
            try {
                // Vérifie s'il y a une opportunité
                const hasOpportunity = await checkFlashLoanOpportunity();
                
                if (hasOpportunity) {
                    // Vérifie le profit minimum
                    const tokenSymbol = document.getElementById('flashloan-token').value;
                    const tokenAddress = TOKENS[tokenSymbol];
                    const amountInput = document.getElementById('flashloan-amount').value || '1';
                    const amount = convertAmount(amountInput, tokenSymbol);
                    
                    const arbitrageCheck = await contract.methods.checkArbitrageOpportunity(
                        tokenAddress,
                        TOKENS.WMATIC,
                        amount
                    ).call();
                    
                    const profitValue = parseFloat(web3.utils.fromWei(arbitrageCheck[1], 'ether'));
                    
                    if (profitValue >= minProfit) {
                        addLog(`Opportunité rentable détectée! Exécution automatique...`, 'success', 'flashloanLogs');
                        await executeFlashLoan();
                    } else {
                        addLog(`Opportunité détectée mais profit insuffisant (${profitValue} < ${minProfit} MATIC)`, 'warning', 'flashloanLogs');
                    }
                }
            } catch (error) {
                console.error('Erreur d\'automatisation:', error);
                addLog(`Erreur lors de la vérification automatique: ${error.message}`, 'error', 'flashloanLogs');
            }
        }, intervalSeconds * 1000);
    }
    
    // Arrête l'automatisation des flash loans
    function stopFlashLoanAutomation() {
        if (autoCheckInterval) {
            clearInterval(autoCheckInterval);
            autoCheckInterval = null;
            addLog('Automatisation des flash loans arrêtée', 'info', 'flashloanLogs');
            showNotification('Automatisation désactivée', 'Les flash loans ne seront plus exécutés automatiquement', 'info');
        }
    }
    
    // =========================================
    // EXÉCUTION DES ARBITRAGES
    // =========================================
    
    // Vérifie les opportunités d'arbitrage
    async function checkArbitrageOpportunity() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'arbitrageLogs');
        return false;
    }
    
    // Récupère les valeurs du formulaire
    const tokenASymbol = document.getElementById('arbitrage-token-a').value;
    const tokenBSymbol = document.getElementById('arbitrage-token-b').value;
    const amountInput = document.getElementById('arbitrage-amount').value || '1';
    
    const tokenAAddress = TOKENS[tokenASymbol];
    const tokenBAddress = TOKENS[tokenBSymbol];
    
    // Convertit le montant
    const amount = convertAmount(amountInput, tokenASymbol);
    
    try {
        addLog(`Vérification d'arbitrage entre ${tokenASymbol} et ${tokenBSymbol} pour ${amountInput} ${tokenASymbol}...`, 'info', 'arbitrageLogs');
        
        // Appel direct à la fonction du contrat
        const result = await contract.methods.checkArbitrageOpportunity(
            tokenAAddress,
            tokenBAddress,
            amount
        ).call();
        
        const isProfitable = result[0];
        const profit = web3.utils.fromWei(result[1], 'ether');
        
        if (isProfitable) {
            addLog(`Opportunité d'arbitrage trouvée! Profit estimé: ${profit} MATIC`, 'success', 'arbitrageLogs');
            showNotification('Opportunité d\'arbitrage', `Profit estimé: ${profit} MATIC`, 'success');
            return true;
        } else {
            addLog(`Aucune opportunité d'arbitrage rentable trouvée (profit: ${profit} MATIC)`, 'warning', 'arbitrageLogs');
            return false;
        }
    } catch (error) {
        console.error('Erreur lors de la vérification d\'arbitrage:', error);
        addLog(`Erreur: ${error.message}`, 'error', 'arbitrageLogs');
        showNotification('Erreur', error.message, 'error');
        return false;
    }
}
    
    // Exécute un arbitrage
    async function executeArbitrage() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'arbitrageLogs');
        return false;
    }
    
    // Récupère les valeurs du formulaire
    const tokenASymbol = document.getElementById('arbitrage-token-a').value;
    const tokenBSymbol = document.getElementById('arbitrage-token-b').value;
    let amountInput = document.getElementById('arbitrage-amount').value || '1';
    const gasPrice = document.getElementById('flashloan-gas-price').value || '50';
    const gasLimit = document.getElementById('flashloan-gas-limit').value || '3000000';
    
    const tokenAAddress = TOKENS[tokenASymbol];
    const tokenBAddress = TOKENS[tokenBSymbol];
    
    // Vérification et ajustement du montant
    if (parseFloat(amountInput) < 700000) {
        addLog(`Le montant fourni (${amountInput}) est inférieur au minimum requis (700000). Ajustement automatique.`, 'warning', 'arbitrageLogs');
        amountInput = '700000';
        document.getElementById('arbitrage-amount').value = '700000';
    }
    
    // Validation
    const validation = validateTransaction(amountInput, tokenASymbol);
    if (!validation.valid) {
        addLog(`Validation échouée: ${validation.message}`, 'error', 'arbitrageLogs');
        showNotification('Erreur de validation', validation.message, 'error');
        return false;
    }
    
    // Convertit le montant
    const amount = convertAmount(amountInput, tokenASymbol);
    
    try {
        addLog(`Préparation de l'arbitrage entre ${tokenASymbol} et ${tokenBSymbol} pour ${amountInput} ${tokenASymbol}...`, 'info', 'arbitrageLogs');
        
        // Créer le chemin pour l'arbitrage multi-hop
        const path = [tokenAAddress, tokenBAddress, tokenAAddress];
        
        // Estimer le gaz
        let estimatedGas;
        try {
            estimatedGas = await contract.methods.executeMultiHopArbitrage(path, amount).estimateGas({
                from: userAccount
            });
            estimatedGas = Math.floor(estimatedGas * 1.2); // Ajouter 20% de marge
            addLog(`Gaz estimé: ${estimatedGas} unités`, 'info', 'arbitrageLogs');
        } catch (gasError) {
            console.error('Erreur d\'estimation de gaz:', gasError);
            addLog(`Erreur d'estimation de gaz: ${gasError.message}. Utilisation du gaz par défaut.`, 'warning', 'arbitrageLogs');
            estimatedGas = parseInt(gasLimit);
        }
        
        // Exécuter l'arbitrage
        const transaction = await contract.methods.executeMultiHopArbitrage(path, amount).send({
            from: userAccount,
            gas: estimatedGas,
            gasPrice: web3.utils.toWei(gasPrice, 'gwei')
        });
        
        addLog(`Transaction d'arbitrage réussie! Hash: ${transaction.transactionHash}`, 'success', 'arbitrageLogs');
        addLog(`Voir sur Polygonscan: https://polygonscan.com/tx/${transaction.transactionHash}`, 'info', 'arbitrageLogs');
        
        // Enregistre la transaction
        recordTransaction('Arbitrage', `${tokenASymbol}-${tokenBSymbol}`, amountInput, '0', transaction.transactionHash);
        
        // Notification
        showNotification('Arbitrage exécuté', 'Transaction envoyée avec succès', 'success');
        
        return true;
    } catch (error) {
        console.error('Erreur lors de l\'exécution de l\'arbitrage:', error);
        addLog(`Erreur: ${error.message}`, 'error', 'arbitrageLogs');
        showNotification('Erreur', `Échec de l'arbitrage: ${error.message.substring(0, 50)}...`, 'error');
        return false;
    }
}
    
    // Active/désactive l'automatisation des arbitrages
function toggleArbitrageAutomation(event) {
    const isChecked = event.target.checked;
    
    // Met à jour les champs associés
    document.getElementById('arbitrage-min-profit').disabled = !isChecked;
    
    if (isChecked) {
        startArbitrageAutomation();
    } else {
        stopArbitrageAutomation();
    }
}

// Démarre l'automatisation des arbitrages
function startArbitrageAutomation() {
    if (autoCheckInterval) {
        clearInterval(autoCheckInterval);
    }
    
    // Seuil de profit minimum en pourcentage
    const minProfitPercent = parseFloat(document.getElementById('arbitrage-min-profit').value) || 0.5;
    
    addLog(`Démarrage de l'automatisation des arbitrages (profit min: ${minProfitPercent}%)`, 'info', 'arbitrageLogs');
    showNotification('Automatisation activée', 'Les arbitrages seront exécutés automatiquement', 'info');
    
    // Réinitialise le cache
    opportunityCache.clearCache();
    
    // Configure l'intervalle d'automatisation
    autoCheckInterval = setInterval(async () => {
        if (!isConnected) return;
        
        try {
            // Vérifie toutes les paires de tokens pour trouver la meilleure opportunité
            const tokenSymbols = Object.keys(TOKENS);
            let bestOpportunity = null;
            
            // Limite le nombre de vérifications pour éviter de surcharger le réseau
            const pairsToCheck = 3; // Vérifie seulement 3 paires aléatoires à chaque cycle
            
            // Sélectionne des paires aléatoires pour cette itération
            for (let i = 0; i < pairsToCheck; i++) {
                const tokenAIndex = Math.floor(Math.random() * tokenSymbols.length);
                let tokenBIndex;
                
                do {
                    tokenBIndex = Math.floor(Math.random() * tokenSymbols.length);
                } while (tokenBIndex === tokenAIndex); // Assure que A ≠ B
                
                const tokenA = tokenSymbols[tokenAIndex];
                const tokenB = tokenSymbols[tokenBIndex];
                
                try {
                    // Vérifie cette paire
                    const cachedResult = await opportunityCache.getOrUpdate(
                        tokenA, 
                        tokenB, 
                        async () => {
                            return await contract.methods.checkArbitrageOpportunity(
                                TOKENS[tokenA],
                                TOKENS[tokenB],
                                convertAmount('1', tokenA) // Montant standard pour les vérifications
                            ).call();
                        }
                    );
                    
                    if (cachedResult[0]) { // Si profitable
                        const profit = parseFloat(web3.utils.fromWei(cachedResult[1], 'ether'));
                        const profitPercent = profit * 100 / parseFloat('1'); // Profit en pourcentage
                        
                        if (!bestOpportunity || profit > bestOpportunity.profit) {
                            bestOpportunity = {
                                tokenA,
                                tokenB,
                                profit,
                                profitPercent
                            };
                        }
                    }
                } catch (error) {
                    console.error(`Erreur lors de la vérification ${tokenA}-${tokenB}:`, error);
                }
            }
            
            // Si une opportunité rentable a été trouvée
            if (bestOpportunity && bestOpportunity.profitPercent >= minProfitPercent) {
                addLog(`Meilleure opportunité: ${bestOpportunity.tokenA}-${bestOpportunity.tokenB} avec ${bestOpportunity.profit.toFixed(4)} MATIC (${bestOpportunity.profitPercent.toFixed(2)}%)`, 'success', 'arbitrageLogs');
                
                // Met à jour les champs du formulaire
                document.getElementById('arbitrage-token-a').value = bestOpportunity.tokenA;
                document.getElementById('arbitrage-token-b').value = bestOpportunity.tokenB;
                document.getElementById('arbitrage-amount').value = '1'; // Valeur standard
                
                // Exécute l'arbitrage
                await executeArbitrage();
                
                // Réinitialise le cache après une exécution
                opportunityCache.clearCache();
            } else if (bestOpportunity) {
                addLog(`Meilleure opportunité: ${bestOpportunity.tokenA}-${bestOpportunity.tokenB} avec ${bestOpportunity.profit.toFixed(4)} MATIC (${bestOpportunity.profitPercent.toFixed(2)}%), mais sous le seuil de ${minProfitPercent}%`, 'info', 'arbitrageLogs');
            } else {
                addLog('Aucune opportunité d\'arbitrage trouvée pour le moment', 'info', 'arbitrageLogs');
            }
        } catch (error) {
            console.error('Erreur d\'automatisation d\'arbitrage:', error);
            addLog(`Erreur lors de la vérification automatique: ${error.message}`, 'error', 'arbitrageLogs');
        }
    }, 30000); // Vérifie toutes les 30 secondes
}

// Arrête l'automatisation des arbitrages
function stopArbitrageAutomation() {
    if (autoCheckInterval) {
        clearInterval(autoCheckInterval);
        autoCheckInterval = null;
        addLog('Automatisation des arbitrages arrêtée', 'info', 'arbitrageLogs');
        showNotification('Automatisation désactivée', 'Les arbitrages ne seront plus exécutés automatiquement', 'info');
    }
}

// =========================================
// LIQUIDATIONS
// =========================================

// Active/désactive l'automatisation des liquidations
function toggleLiquidationAutomation(event) {
    const isChecked = event.target.checked;
    
    // Met à jour le champ associé
    document.getElementById('liquidation-max-capital').disabled = !isChecked;
    
    if (isChecked) {
        addLog('Automatisation des liquidations activée', 'info', 'liquidationLogs');
        showNotification('Automatisation activée', 'Les liquidations seront exécutées automatiquement', 'info');
    } else {
        addLog('Automatisation des liquidations désactivée', 'info', 'liquidationLogs');
        showNotification('Automatisation désactivée', 'Les liquidations ne seront plus exécutées automatiquement', 'info');
    }
}

// Démarre le scan des opportunités de liquidation
function startLiquidationScan() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'liquidationLogs');
        return;
    }
    
    if (isAutomationRunning) {
        addLog('Le scan est déjà en cours', 'warning', 'liquidationLogs');
        return;
    }
    
    isAutomationRunning = true;
    
    // Met à jour l'interface
    document.getElementById('startLiquidationScanBtn').disabled = true;
    document.getElementById('stopLiquidationScanBtn').disabled = false;
    
    addLog('Démarrage du scan de liquidations...', 'info', 'liquidationLogs');
    showNotification('Scan démarré', 'Le scan de liquidations est maintenant actif', 'info');
    
    // Configure l'intervalle de scan
    autoCheckInterval = setInterval(() => {
        checkForLiquidations();
    }, 10000); // Vérifie toutes les 10 secondes
}

// Arrête le scan des opportunités de liquidation
function stopLiquidationScan() {
    if (!isAutomationRunning) {
        addLog('Aucun scan en cours', 'warning', 'liquidationLogs');
        return;
    }
    
    clearInterval(autoCheckInterval);
    isAutomationRunning = false;
    
    // Met à jour l'interface
    document.getElementById('startLiquidationScanBtn').disabled = false;
    document.getElementById('stopLiquidationScanBtn').disabled = true;
    
    addLog('Scan de liquidations arrêté', 'info', 'liquidationLogs');
    showNotification('Scan arrêté', 'Le scan de liquidations a été arrêté', 'info');
}

// Vérifie les opportunités de liquidation 
async function checkForLiquidations() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'liquidationLogs');
        return [];
    }

    try {
        addLog('Recherche d\'opportunités de liquidation sur la blockchain...', 'info', 'liquidationLogs');
        
        // Cette partie dépend fortement de la structure de votre contrat
        // Voici un exemple basé sur le contrat que vous avez partagé
        const lendingPool = new web3.eth.Contract(
            // ABI simplifié du contrat de prêt (à adapter selon votre contrat réel)
            [
                {
                    "inputs": [],
                    "name": "getLiquidationOpportunities",
                    "outputs": [
                        {
                            "internalType": "address[]",
                            "name": "users",
                            "type": "address[]"
                        },
                        {
                            "internalType": "address[]",
                            "name": "collateralAssets",
                            "type": "address[]"
                        },
                        {
                            "internalType": "address[]",
                            "name": "debtAssets",
                            "type": "address[]"
                        },
                        {
                            "internalType": "uint256[]",
                            "name": "healthFactors",
                            "type": "uint256[]"
                        }
                    ],
                    "stateMutability": "view",
                    "type": "function"
                }
            ],
            lendingPoolAddress // Utiliser l'adresse du pool de prêt définie dans vos constantes
        );
        
        // Appeler la fonction pour obtenir les opportunités
        const result = await lendingPool.methods.getLiquidationOpportunities().call();
        
        const opportunities = [];
        
        // Parcourir les résultats
        for (let i = 0; i < result.users.length; i++) {
            if (result.healthFactors[i] < 1e18) { // Si le facteur de santé est inférieur à 1.0
                opportunities.push({
                    user: result.users[i],
                    collateralAsset: result.collateralAssets[i],
                    debtAsset: result.debtAssets[i],
                    healthFactor: web3.utils.fromWei(result.healthFactors[i], 'ether')
                });
                
                addLog(`Opportunité trouvée: ${shortenAddress(result.users[i])} - Facteur de santé: ${web3.utils.fromWei(result.healthFactors[i], 'ether')}`, 'success', 'liquidationLogs');
            }
        }
        
        // Mettre à jour l'interface avec le nombre d'opportunités
        document.querySelector('.card-grid .card:nth-child(1) .card-value').textContent = opportunities.length;
        document.querySelector('.card-grid .card:nth-child(1) .card-footer').textContent = `Dernières 24h: ${opportunities.length}`;
        
        return opportunities;
    } catch (error) {
        console.error('Erreur lors de la vérification des liquidations:', error);
        addLog(`Erreur: ${error.message}`, 'error', 'liquidationLogs');
        return [];
    }
}

// Exécute une liquidation - IMPLÉMENTATION RÉELLE
async function executeLiquidation(user, collateralAsset, debtAsset) {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'liquidationLogs');
        return false;
    }
    
    try {
        addLog(`Préparation de la liquidation pour l'emprunteur ${shortenAddress(user)}...`, 'info', 'liquidationLogs');
        
        // Paramètres de la transaction
        const gasPrice = document.getElementById('flashloan-gas-price').value || '50';
        const gasLimit = document.getElementById('flashloan-gas-limit').value || '3000000';
        
        // Estimer le gaz
        let estimatedGas;
        try {
            estimatedGas = await contract.methods.executeLiquidation(user, collateralAsset, debtAsset).estimateGas({
                from: userAccount
            });
            estimatedGas = Math.floor(estimatedGas * 1.2); // Ajouter 20% de marge
            addLog(`Gaz estimé: ${estimatedGas} unités`, 'info', 'liquidationLogs');
        } catch (gasError) {
            console.error('Erreur d\'estimation de gaz:', gasError);
            addLog(`Erreur d'estimation de gaz: ${gasError.message}. Utilisation du gaz par défaut.`, 'warning', 'liquidationLogs');
            estimatedGas = parseInt(gasLimit);
        }
        
        // Désactiver le bouton pendant la transaction
        document.getElementById('startLiquidationScanBtn').disabled = true;
        
        // Exécuter la liquidation
        const transaction = await contract.methods.executeLiquidation(user, collateralAsset, debtAsset).send({
            from: userAccount,
            gas: estimatedGas,
            gasPrice: web3.utils.toWei(gasPrice, 'gwei')
        });
        
        // Traitement réussi
        addLog(`Liquidation réussie! Hash: ${transaction.transactionHash}`, 'success', 'liquidationLogs');
        addLog(`Voir sur Polygonscan: https://polygonscan.com/tx/${transaction.transactionHash}`, 'info', 'liquidationLogs');
        
        // Obtenir les symboles des tokens pour l'affichage
        const collateralSymbol = getTokenSymbolByAddress(collateralAsset);
        const debtSymbol = getTokenSymbolByAddress(debtAsset);
        
        // Enregistrer la transaction
        recordTransaction('Liquidation', `${collateralSymbol}/${debtSymbol}`, '0', '0', transaction.transactionHash);
        
        // Notification
        showNotification('Liquidation réussie', 'Transaction envoyée avec succès', 'success');
        
        // Réactiver le bouton
        document.getElementById('startLiquidationScanBtn').disabled = false;
        
        // Mettre à jour les statistiques de liquidation
        incrementLiquidationStats();
        
        return true;
    } catch (error) {
        console.error('Erreur lors de l\'exécution de la liquidation:', error);
        addLog(`Erreur: ${error.message}`, 'error', 'liquidationLogs');
        
        // Réactiver le bouton
        document.getElementById('startLiquidationScanBtn').disabled = false;
        
        return false;
    }
}

// Fonction helper pour incrémenter les statistiques de liquidation
function incrementLiquidationStats() {
    // Mettre à jour le nombre de liquidations exécutées
    const liquidationsElement = document.querySelector('.card-grid .card:nth-child(2) .card-value');
    const currentLiquidations = parseInt(liquidationsElement.textContent) || 0;
    liquidationsElement.textContent = (currentLiquidations + 1).toString();
    
    // Mettre à jour le total
    const totalElement = document.querySelector('.card-grid .card:nth-child(2) .card-footer');
    const currentTotal = parseInt(totalElement.textContent.split(': ')[1]) || 0;
    totalElement.textContent = `Total: ${currentTotal + 1}`;
}

// Fonction qui assure que l'ABI du contrat inclut les méthodes de liquidation
function ensureLiquidationMethods() {
    // Vérifier si les méthodes de liquidation sont disponibles dans l'ABI
    const hasLiquidationMethods = CONTRACT_ABI.some(method => 
        method.name === 'checkLiquidationOpportunities' || 
        method.name === 'executeLiquidation'
    );
    
    if (!hasLiquidationMethods) {
        addLog('ATTENTION: Les méthodes de liquidation ne semblent pas être présentes dans l\'ABI du contrat', 'warning', 'liquidationLogs');
        addLog('Veuillez mettre à jour l\'ABI pour inclure checkLiquidationOpportunities et executeLiquidation', 'warning', 'liquidationLogs');
        
        // Ajouter les méthodes à l'ABI existant
        CONTRACT_ABI.push(
            {
                "inputs": [],
                "name": "checkLiquidationOpportunities",
                "outputs": [
                    {
                        "components": [
                            {
                                "internalType": "address[]",
                                "name": "borrowers",
                                "type": "address[]"
                            },
                            {
                                "internalType": "address[]",
                                "name": "collateralTokens",
                                "type": "address[]"
                            },
                            {
                                "internalType": "address[]",
                                "name": "debtTokens",
                                "type": "address[]"
                            },
                            {
                                "internalType": "uint256[]",
                                "name": "collateralAmounts",
                                "type": "uint256[]"
                            },
                            {
                                "internalType": "uint256[]",
                                "name": "debtAmounts",
                                "type": "uint256[]"
                            },
                            {
                                "internalType": "uint256[]",
                                "name": "expectedProfits",
                                "type": "uint256[]"
                            }
                        ],
                        "internalType": "struct IMaxBot.LiquidationOpportunities",
                        "name": "",
                        "type": "tuple"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "borrower",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "collateralToken",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "debtToken",
                        "type": "address"
                    }
                ],
                "name": "executeLiquidation",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        );
        
        addLog('ABI mis à jour pour inclure les méthodes de liquidation', 'info', 'liquidationLogs');
    }
}

// Appeler cette fonction lors de l'initialisation
document.addEventListener('DOMContentLoaded', function() {
    const originalSetupEventListeners = setupEventListeners;
    
    // Redéfinir setupEventListeners pour inclure nos vérifications
    window.setupEventListeners = function() {
        originalSetupEventListeners();
        ensureLiquidationMethods();
    };
});

// =========================================
// INITIALISATION FINALE
// =========================================

// Fonction utilitaire pour créer des modales de confirmation
function createConfirmationModal(title, message, onConfirm) {
    // Supprime une modale existante si présente
    const existingModal = document.querySelector('.modal-overlay');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Crée la structure de la modale
    const modalOverlay = document.createElement('div');
    modalOverlay.className = 'modal-overlay';
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    
    modal.innerHTML = `
        <h2 class="modal-title">${title}</h2>
        <p>${message}</p>
        <div class="modal-buttons">
            <button class="action-button" id="modal-cancel">Annuler</button>
            <button class="action-button" id="modal-confirm">Confirmer</button>
        </div>
    `;
    
    modalOverlay.appendChild(modal);
    document.body.appendChild(modalOverlay);
    
    // Configure les boutons
    document.getElementById('modal-cancel').addEventListener('click', () => {
        modalOverlay.remove();
    });
    
    document.getElementById('modal-confirm').addEventListener('click', () => {
        onConfirm();
        modalOverlay.remove();
    });
    
    // Ferme la modale si on clique en dehors
    modalOverlay.addEventListener('click', (event) => {
        if (event.target === modalOverlay) {
            modalOverlay.remove();
        }
    });
}

// Donne des indications à l'utilisateur sur la première utilisation
if (!localStorage.getItem('maxbot_first_use')) {
    // Ajoute un délai pour laisser l'interface se charger
    setTimeout(() => {
        showNotification(
            'Bienvenue sur MaxBot Professional',
            'Connectez votre wallet avec MetaMask pour commencer à utiliser toutes les fonctionnalités.',
            'info'
        );
        
        localStorage.setItem('maxbot_first_use', 'true');
    }, 2000);
}

// Console d'accueil
console.log('%c MaxBot Professional Controller', 'font-size:20px; color:#00c853; font-weight:bold;');
console.log('%c Version 1.0.0 - Développé pour l\'utilisation avec le contrat MaxBot', 'font-size:12px; color:#9e9e9e;');
// =========================================
// EXTENSIONS MAXBOT
// =========================================

// Variables pour les extensions
let morpheusTraderAddress = '';
let scannerServiceAddress = '';
let mlOptimizerAddress = '';

// ABI des extensions
const MORPHEUS_TRADER_ABI = [
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "minAmountOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "maxSlippage",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "useMEVProtection",
                        "type": "bool"
                    },
                    {
                        "internalType": "uint256",
                        "name": "gasPrice",
                        "type": "uint256"
                    }
                ],
                "internalType": "struct IMorpheusTrader.TradeParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "executeTrade",
        "outputs": [
            {
                "components": [
                    {
                        "internalType": "bool",
                        "name": "success",
                        "type": "bool"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "gasUsed",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "executionTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "string",
                        "name": "route",
                        "type": "string"
                    }
                ],
                "internalType": "struct IMorpheusTrader.TradeResult",
                "name": "",
                "type": "tuple"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "tokenIn",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "tokenOut",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            }
        ],
        "name": "findBestRoute",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "path",
                "type": "address[]"
            },
            {
                "internalType": "address[]",
                "name": "routers",
                "type": "address[]"
            },
            {
                "internalType": "uint256",
                "name": "expectedOutput",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "expectedGas",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
];

// Gestionnaire d'événements pour les extensions
function setupExtensionsEventListeners() {
    // MorpheusTrader
    document.getElementById('findBestRouteBtn').addEventListener('click', findBestRoute);
    document.getElementById('executeWithMorpheusBtn').addEventListener('click', executeWithMorpheus);
    
    // ScannerService
    document.getElementById('scanner-auto-mode').addEventListener('change', toggleScannerAutomation);
    
    // MLOptimizer
    document.getElementById('ml-auto-mode').addEventListener('change', toggleMLAutomation);
    document.getElementById('forceMLUpdateBtn').addEventListener('click', forceMLUpdate);
    document.getElementById('resetMLBtn').addEventListener('click', resetML);
    
    // Configuration des adresses
    document.getElementById('setExtensionsBtn').addEventListener('click', setExtensionsAddresses);
}

// Initialiser les extensions lors de la connexion
function initializeExtensions() {
    if (!isConnected) return;
    
    try {
        // Récupérer les adresses des extensions si elles sont présentes dans le contrat
        contract.methods.morpheusTraderAddress().call()
            .then(address => {
                if (address && address !== '0x0000000000000000000000000000000000000000') {
                    morpheusTraderAddress = address;
                    document.getElementById('morpheus-address').value = address;
                    addLog('MorpheusTrader détecté: ' + shortenAddress(address), 'info', 'morpheusLogs');
                    enableMorpheusControls();
                }
            })
            .catch(error => {
                console.error('Erreur lors de la récupération de l\'adresse MorpheusTrader:', error);
            });
        
        contract.methods.scannerServiceAddress().call()
            .then(address => {
                if (address && address !== '0x0000000000000000000000000000000000000000') {
                    scannerServiceAddress = address;
                    document.getElementById('scanner-address').value = address;
                    addLog('ScannerService détecté: ' + shortenAddress(address), 'info', 'morpheusLogs');
                    document.getElementById('scanner-auto-mode').disabled = false;
                    document.getElementById('scanner-confidence').disabled = false;
                }
            })
            .catch(error => {
                console.error('Erreur lors de la récupération de l\'adresse ScannerService:', error);
            });
        
        contract.methods.mlOptimizerAddress().call()
            .then(address => {
                if (address && address !== '0x0000000000000000000000000000000000000000') {
                    mlOptimizerAddress = address;
                    document.getElementById('ml-address').value = address;
                    addLog('MLOptimizer détecté: ' + shortenAddress(address), 'info', 'mlLogs');
                    document.getElementById('ml-auto-mode').disabled = false;
                    document.getElementById('forceMLUpdateBtn').disabled = false;
                    document.getElementById('resetMLBtn').disabled = false;
                }
            })
            .catch(error => {
                console.error('Erreur lors de la récupération de l\'adresse MLOptimizer:', error);
            });
        
        // Activer le bouton d'enregistrement des adresses
        document.getElementById('setExtensionsBtn').disabled = false;
        
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des extensions:', error);
        addLog('Erreur d\'initialisation des extensions: ' + error.message, 'error', 'morpheusLogs');
    }
}

// Activer les contrôles de MorpheusTrader
function enableMorpheusControls() {
    document.getElementById('findBestRouteBtn').disabled = false;
    document.getElementById('executeWithMorpheusBtn').disabled = false;
}

// Définir les adresses des extensions
async function setExtensionsAddresses() {
    if (!isConnected) {
        showNotification('Non connecté', 'Veuillez vous connecter d\'abord', 'error');
        return;
    }
    
    try {
        addLog('Mise à jour des adresses des extensions...', 'info', 'morpheusLogs');
        
        const newMorpheusAddress = document.getElementById('morpheus-address').value;
        const newScannerAddress = document.getElementById('scanner-address').value;
        const newMLAddress = document.getElementById('ml-address').value;
        
        // Vérifier que les adresses sont valides
        if (newMorpheusAddress && !web3.utils.isAddress(newMorpheusAddress)) {
            showNotification('Adresse invalide', 'L\'adresse de MorpheusTrader n\'est pas valide', 'error');
            return;
        }
        
        if (newScannerAddress && !web3.utils.isAddress(newScannerAddress)) {
            showNotification('Adresse invalide', 'L\'adresse de ScannerService n\'est pas valide', 'error');
            return;
        }
        
        if (newMLAddress && !web3.utils.isAddress(newMLAddress)) {
            showNotification('Adresse invalide', 'L\'adresse de MLOptimizer n\'est pas valide', 'error');
            return;
        }
        
        // Mettre à jour MorpheusTrader
        if (newMorpheusAddress && newMorpheusAddress !== morpheusTraderAddress) {
            await contract.methods.setMorpheusTrader(newMorpheusAddress).send({
                from: userAccount
            });
            morpheusTraderAddress = newMorpheusAddress;
            addLog('MorpheusTrader mis à jour: ' + shortenAddress(newMorpheusAddress), 'success', 'morpheusLogs');
            enableMorpheusControls();
        }
        
        // Mettre à jour ScannerService
        if (newScannerAddress && newScannerAddress !== scannerServiceAddress) {
            await contract.methods.setScannerService(newScannerAddress).send({
                from: userAccount
            });
            scannerServiceAddress = newScannerAddress;
            addLog('ScannerService mis à jour: ' + shortenAddress(newScannerAddress), 'success', 'morpheusLogs');
            document.getElementById('scanner-auto-mode').disabled = false;
            document.getElementById('scanner-confidence').disabled = false;
        }
        
        // Mettre à jour MLOptimizer
        if (newMLAddress && newMLAddress !== mlOptimizerAddress) {
            await contract.methods.setMLOptimizer(newMLAddress).send({
                from: userAccount
            });
            mlOptimizerAddress = newMLAddress;
            addLog('MLOptimizer mis à jour: ' + shortenAddress(newMLAddress), 'success', 'mlLogs');
            document.getElementById('ml-auto-mode').disabled = false;
            document.getElementById('forceMLUpdateBtn').disabled = false;
            document.getElementById('resetMLBtn').disabled = false;
        }
        
        showNotification('Extensions mises à jour', 'Les adresses des extensions ont été mises à jour avec succès', 'success');
        
    } catch (error) {
        console.error('Erreur lors de la mise à jour des adresses:', error);
        addLog('Erreur de mise à jour: ' + error.message, 'error', 'morpheusLogs');
        showNotification('Erreur', 'Impossible de mettre à jour les adresses des extensions', 'error');
    }
}

// Trouver le meilleur itinéraire avec MorpheusTrader
async function findBestRoute() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'morpheusLogs');
        return;
    }
    
    if (!morpheusTraderAddress) {
        addLog('MorpheusTrader n\'est pas configuré', 'error', 'morpheusLogs');
        return;
    }
    
    try {
        // Récupérer les valeurs du formulaire
        const tokenInSymbol = document.getElementById('morpheus-token-in').value;
        const tokenOutSymbol = document.getElementById('morpheus-token-out').value;
        const amountInput = document.getElementById('morpheus-amount').value || '100';
        
        const tokenInAddress = TOKENS[tokenInSymbol];
        const tokenOutAddress = TOKENS[tokenOutSymbol];
        
        // Convertir le montant
        const amount = convertAmount(amountInput, tokenInSymbol);
        
        addLog(`Recherche du meilleur itinéraire pour ${amountInput} ${tokenInSymbol} → ${tokenOutSymbol}...`, 'info', 'morpheusLogs');
        
        // Appeler la fonction getOptimalTradeRoute du contrat MaxBot
        const result = await contract.methods.getOptimalTradeRoute(
            tokenInAddress,
            tokenOutAddress,
            amount
        ).call();
        
        // Analyser les résultats
        const path = result[0];
        const routers = result[1];
        const expectedOutput = formatAmount(result[2], tokenOutSymbol);
        
        // Afficher les résultats
        let routeDisplay = '';
        for (let i = 0; i < path.length; i++) {
            const tokenSymbol = getTokenSymbolByAddress(path[i]);
            routeDisplay += tokenSymbol;
            if (i < path.length - 1) {
                const routerName = getRouterNameByAddress(routers[i]);
                routeDisplay += ` → [${routerName}] → `;
            }
        }
        
        addLog(`Meilleur itinéraire trouvé: ${routeDisplay}`, 'success', 'morpheusLogs');
        addLog(`Sortie estimée: ${expectedOutput} ${tokenOutSymbol}`, 'info', 'morpheusLogs');
        
        return true;
    } catch (error) {
        console.error('Erreur lors de la recherche du meilleur itinéraire:', error);
        addLog('Erreur: ' + error.message, 'error', 'morpheusLogs');
        return false;
    }
}

// Exécuter un trade avec MorpheusTrader
async function executeWithMorpheus() {
    if (!isConnected) {
        addLog('Veuillez d\'abord vous connecter', 'error', 'morpheusLogs');
        return;
    }
    
    if (!morpheusTraderAddress) {
        addLog('MorpheusTrader n\'est pas configuré', 'error', 'morpheusLogs');
        return;
    }
    
    try {
        // Récupérer les valeurs du formulaire
        const tokenInSymbol = document.getElementById('morpheus-token-in').value;
        const tokenOutSymbol = document.getElementById('morpheus-token-out').value;
        const amountInput = document.getElementById('morpheus-amount').value || '100';
        const maxSlippage = parseFloat(document.getElementById('morpheus-slippage').value) || 1;
        const useMEVProtection = document.getElementById('morpheus-mev').checked;
        
        const tokenInAddress = TOKENS[tokenInSymbol];
        const tokenOutAddress = TOKENS[tokenOutSymbol];
        
        // Validation
        const validation = validateTransaction(amountInput, tokenInSymbol);
        if (!validation.valid) {
            addLog(`Validation échouée: ${validation.message}`, 'error', 'morpheusLogs');
            showNotification('Erreur de validation', validation.message, 'error');
            return;
        }
        
        // Convertir le montant
        const amount = convertAmount(amountInput, tokenInSymbol);
        
        addLog(`Préparation du trade: ${amountInput} ${tokenInSymbol} → ${tokenOutSymbol}...`, 'info', 'morpheusLogs');
        
        // Appeler la fonction executeWithMorpheus du contrat MaxBot
        const transaction = await contract.methods.executeWithMorpheus(
            tokenInAddress,
            tokenOutAddress,
            amount,
            maxSlippage * 100 // Convertir le pourcentage en points de base
        ).send({
            from: userAccount,
            gas: 3000000,
            gasPrice: web3.utils.toWei('50', 'gwei')
        });
        
        // Transaction réussie
        addLog(`Transaction réussie! Hash: ${transaction.transactionHash}`, 'success', 'morpheusLogs');
        addLog(`Voir sur Polygonscan: https://polygonscan.com/tx/${transaction.transactionHash}`, 'info', 'morpheusLogs');
        
        // Enregistrer la transaction
        recordTransaction('MorpheusTrader', `${tokenInSymbol}->${tokenOutSymbol}`, amountInput, '0', transaction.transactionHash);
        
        // Notification
        showNotification('Trade exécuté', 'Transaction envoyée avec succès', 'success');
        
        return true;
    } catch (error) {
        console.error('Erreur lors de l\'exécution du trade:', error);
        addLog('Erreur: ' + error.message, 'error', 'morpheusLogs');
        showNotification('Erreur', 'Impossible d\'exécuter le trade', 'error');
        return false;
    }
}

// Active/désactive l'automatisation du Scanner
function toggleScannerAutomation(event) {
    const isChecked = event.target.checked;
    
    if (isChecked) {
        addLog('Automatisation du scanner activée', 'info', 'morpheusLogs');
        showNotification('Scanner activé', 'Le scanner d\'opportunités est maintenant actif', 'info');
        // Implémentation de l'automatisation du scanner (à développer)
    } else {
        addLog('Automatisation du scanner désactivée', 'info', 'morpheusLogs');
        showNotification('Scanner désactivé', 'Le scanner d\'opportunités est maintenant inactif', 'info');
        // Arrêt de l'automatisation du scanner (à développer)
    }
}

// Active/désactive l'automatisation du ML
function toggleMLAutomation(event) {
    const isChecked = event.target.checked;
    
    if (isChecked) {
        addLog('Optimisation ML activée', 'info', 'mlLogs');
        showNotification('ML activé', 'L\'optimisation ML est maintenant active', 'info');
        // Activation de l'apprentissage automatique (à développer)
    } else {
        addLog('Optimisation ML désactivée', 'info', 'mlLogs');
        showNotification('ML désactivé', 'L\'optimisation ML est maintenant inactive', 'info');
        // Arrêt de l'apprentissage automatique (à développer)
    }
}

// Force une mise à jour des paramètres ML
async function forceMLUpdate() {
    if (!isConnected || !mlOptimizerAddress) {
        addLog('MLOptimizer n\'est pas configuré ou vous n\'êtes pas connecté', 'error', 'mlLogs');
        return;
    }
    
    try {
        addLog('Demande de mise à jour des paramètres ML...', 'info', 'mlLogs');
        
        // Créer une instance du contrat MLOptimizer
        const mlOptimizer = new web3.eth.Contract(
            // ABI simplifié (à adapter selon votre contrat réel)
            [
                {
                    "inputs": [],
                    "name": "updateParameters",
                    "outputs": [
                        {
                            "internalType": "uint128",
                            "name": "minProfit",
                            "type": "uint128"
                        },
                        {
                            "internalType": "uint128",
                            "name": "maxTradeSize",
                            "type": "uint128"
                        },
                        {
                            "internalType": "uint8",
                            "name": "performanceImprovement",
                            "type": "uint8"
                        }
                    ],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ],
            mlOptimizerAddress
        );
        
        // Appeler la fonction de mise à jour
        const transaction = await mlOptimizer.methods.updateParameters().send({
            from: userAccount,
            gas: 300000
        });
        
        // Obtenir les résultats de la mise à jour
        const events = transaction.events;
        if (events && events.ParametersUpdated) {
            const result = events.ParametersUpdated.returnValues;
            
            // Mettre à jour l'interface
            document.querySelector('.card-grid .card:nth-child(1) .card-value').textContent = `${result.performanceImprovement}%`;
            document.querySelector('.card-grid .card:nth-child(1) .card-footer').innerHTML = `Amélioration: <span class="card-positive">+${result.performanceImprovement}%</span>`;
            document.querySelector('.card-grid .card:nth-child(2) .card-value').textContent = new Date().toLocaleString();
            document.querySelector('.card-grid .card:nth-child(2) .card-footer').textContent = 'Épisodes: 12';
        } else {
            // Mise à jour par défaut si les événements ne sont pas disponibles
            document.querySelector('.card-grid .card:nth-child(1) .card-value').textContent = '15%';
            document.querySelector('.card-grid .card:nth-child(1) .card-footer').innerHTML = 'Amélioration: <span class="card-positive">+5%</span>';
            document.querySelector('.card-grid .card:nth-child(2) .card-value').textContent = new Date().toLocaleString();
            document.querySelector('.card-grid .card:nth-child(2) .card-footer').textContent = 'Épisodes: 12';
        }
        
        addLog('Paramètres ML mis à jour avec succès', 'success', 'mlLogs');
        showNotification('ML mis à jour', 'Les paramètres d\'optimisation ont été mis à jour', 'success');
        
    } catch (error) {
        console.error('Erreur lors de la mise à jour ML:', error);
        addLog('Erreur: ' + error.message, 'error', 'mlLogs');
        showNotification('Erreur', 'Impossible de mettre à jour les paramètres ML', 'error');
    }
}

// Fonction pour vérifier la validité des transactions
async function verifyTransactions() {
    if (!isConnected || !web3) return;
    
    try {
        let invalidFound = false;
        
        for (let i = 0; i < Math.min(transactions.length, 10); i++) {  // Vérifie les 10 dernières transactions
            const tx = transactions[i];
            
            // Vérifier si la transaction existe sur la blockchain
            const receipt = await web3.eth.getTransactionReceipt(tx.hash);
            
            if (!receipt) {
                console.warn(`Transaction invalide détectée: ${tx.hash}`);
                tx.status = 'invalid';
                invalidFound = true;
                
                // Marquer la transaction comme invalide dans l'interface
                const rows = document.querySelectorAll('#transactionsTable tr');
                if (rows[i]) {
                    const statusCell = rows[i].querySelector('td:last-child');
                    if (statusCell) {
                        statusCell.innerHTML = '<span style="color: var(--error-color);">Non trouvée</span>';
                    }
                }
            }
        }
        
        if (invalidFound) {
            addLog('⚠️ Attention: Des transactions invalides ont été détectées dans l\'historique', 'warning', 'all');
            showNotification('Transactions suspectes', 'Certaines transactions n\'existent pas sur la blockchain', 'warning');
        }
        
        // Mettre à jour l'interface
        updateTransactionsTable();
    } catch (error) {
        console.error('Erreur lors de la vérification des transactions:', error);
    }
}

// Vérifier les transactions après connexion et périodiquement
// contract-fix.js
(function() {
    document.addEventListener('DOMContentLoaded', function() {
        // Bouton de diagnostic
        const diagnosticBtn = document.getElementById('debugContractBtn');
        if (diagnosticBtn) {
            // Remplacer l'ancien gestionnaire d'événement
            const oldHandler = diagnosticBtn.onclick;
            diagnosticBtn.onclick = null;
            
            // Nouveau gestionnaire avec correction
            diagnosticBtn.addEventListener('click', async function() {
                const debugLogs = document.getElementById('debugLogs');
                const contractAddress = document.getElementById('contract-address').value;
                
                debugLogs.innerHTML = `
                    <div class="log-entry log-info">
                        <span class="log-time">[Diagnostic]</span> Vérification du contrat à l'adresse ${contractAddress}...
                    </div>
                `;
                
                try {
                    // Vérifier que Web3 est disponible 
                    if (typeof Web3 === 'undefined') {
                        debugLogs.innerHTML += `
                            <div class="log-entry log-error">
                                <span class="log-time">[Erreur]</span> La bibliothèque Web3 n'est pas chargée
                            </div>
                        `;
                        return;
                    }
                    
                    // Créer une instance Web3 locale pour le diagnostic
                    let web3Instance;
                    if (window.ethereum) {
                        web3Instance = new Web3(window.ethereum);
                    } else if (window.web3) {
                        web3Instance = new Web3(window.web3.currentProvider);
                    } else {
                        throw new Error("Aucun provider Web3 détecté");
                    }
                    
                    // Vérifier si le contrat existe
                    const code = await web3Instance.eth.getCode(contractAddress);
                    if (code === '0x' || code === '0x0') {
                        debugLogs.innerHTML += `
                            <div class="log-entry log-error">
                                <span class="log-time">[Contrat]</span> Aucun contrat déployé à cette adresse!
                            </div>
                        `;
                        return;
                    }
                    
                    debugLogs.innerHTML += `
                        <div class="log-entry log-success">
                            <span class="log-time">[Contrat]</span> Contrat détecté à l'adresse ${contractAddress}
                        </div>
                    `;
                    
                    // CORRECTION : Créer une nouvelle instance du contrat avec web3Instance
                    const contract = new web3Instance.eth.Contract(CONTRACT_ABI, contractAddress);
                    
                    // Stocker l'instance globalement - C'EST LA CORRECTION CLÉ
                    window.contract = contract;
                    
                    // Tester les méthodes principales
                    const methods = ['forceExecuteFlashLoan', 'checkArbitrageOpportunity', 'isOperational'];
                    
                    for (const method of methods) {
                        try {
                            if (!contract.methods[method]) {
                                debugLogs.innerHTML += `
                                    <div class="log-entry log-warning">
                                        <span class="log-time">[Méthode]</span> ${method} n'existe pas dans l'ABI
                                    </div>
                                `;
                                continue;
                            }
                            
                            // Pour les méthodes view simples, essayer de les appeler
                            if (method === 'isOperational') {
                                try {
                                    const result = await contract.methods[method]().call();
                                    debugLogs.innerHTML += `
                                        <div class="log-entry log-success">
                                            <span class="log-time">[${method}]</span> Résultat: ${result}
                                        </div>
                                    `;
                                } catch (callError) {
                                    debugLogs.innerHTML += `
                                        <div class="log-entry log-error">
                                            <span class="log-time">[${method}]</span> Erreur d'appel: ${callError.message}
                                        </div>
                                    `;
                                }
                            } else {
                                debugLogs.innerHTML += `
                                    <div class="log-entry log-info">
                                        <span class="log-time">[${method}]</span> Présent dans l'ABI
                                    </div>
                                `;
                            }
                        } catch (methodError) {
                            debugLogs.innerHTML += `
                                <div class="log-entry log-error">
                                    <span class="log-time">[${method}]</span> Erreur: ${methodError.message}
                                </div>
                            `;
                        }
                    }
                    
                    debugLogs.innerHTML += `
                        <div class="log-entry log-success">
                            <span class="log-time">[Correction]</span> L'instance du contrat a été correctement réinitialisée!
                        </div>
                    `;
                    
                } catch (error) {
                    debugLogs.innerHTML += `
                        <div class="log-entry log-error">
                            <span class="log-time">[Erreur]</span> ${error.message}
                        </div>
                    `;
                }
            });
        }
    });
})();

// Fonction réelle pour initialiser les extensions
async function initializeExtensions() {
    if (!isConnected || !contract) {
        addLog('Impossible d\'initialiser les extensions sans connexion', 'error', 'all');
        return false;
    }
    
    try {
        // Vérifier MorpheusTrader
        try {
            const morpheusAddress = await contract.methods.morpheusTraderAddress().call();
            if (morpheusAddress && morpheusAddress !== '0x0000000000000000000000000000000000000000') {
                morpheusTraderAddress = morpheusAddress;
                document.getElementById('morpheus-address').value = morpheusAddress;
                addLog('MorpheusTrader détecté: ' + shortenAddress(morpheusAddress), 'info', 'morpheusLogs');
                document.getElementById('findBestRouteBtn').disabled = false;
                document.getElementById('executeWithMorpheusBtn').disabled = false;
            }
        } catch (error) {
            console.log('MorpheusTrader non disponible:', error.message);
        }
        
        // Vérifier ScannerService
        try {
            const scannerAddress = await contract.methods.scannerServiceAddress().call();
            if (scannerAddress && scannerAddress !== '0x0000000000000000000000000000000000000000') {
                scannerServiceAddress = scannerAddress;
                document.getElementById('scanner-address').value = scannerAddress;
                addLog('ScannerService détecté: ' + shortenAddress(scannerAddress), 'info', 'morpheusLogs');
                document.getElementById('scanner-auto-mode').disabled = false;
                document.getElementById('scanner-confidence').disabled = false;
            }
        } catch (error) {
            console.log('ScannerService non disponible:', error.message);
        }
        
        // Vérifier MLOptimizer
        try {
            const mlAddress = await contract.methods.mlOptimizerAddress().call();
            if (mlAddress && mlAddress !== '0x0000000000000000000000000000000000000000') {
                mlOptimizerAddress = mlAddress;
                document.getElementById('ml-address').value = mlAddress;
                addLog('MLOptimizer détecté: ' + shortenAddress(mlAddress), 'info', 'mlLogs');
                document.getElementById('ml-auto-mode').disabled = false;
                document.getElementById('forceMLUpdateBtn').disabled = false;
                document.getElementById('resetMLBtn').disabled = false;
            }
        } catch (error) {
            console.log('MLOptimizer non disponible:', error.message);
        }
        
        return true;
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des extensions:', error);
        addLog('Erreur d\'initialisation des extensions: ' + error.message, 'error', 'all');
        return false;
    }
}

// Réinitialise l'optimiseur ML
async function resetML() {
    if (!isConnected || !mlOptimizerAddress) {
        addLog('MLOptimizer n\'est pas configuré ou vous n\'êtes pas connecté', 'error', 'mlLogs');
        return;
    }
    
    try {
        addLog('Réinitialisation du modèle ML...', 'info', 'mlLogs');
        
        // Simuler une réinitialisation (à remplacer par l'implémentation réelle)
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Mettre à jour l'interface
        document.querySelector('.card-grid .card:nth-child(1) .card-value').textContent = '0%';
        document.querySelector('.card-grid .card:nth-child(1) .card-footer').innerHTML = 'Amélioration: <span class="card-positive">+0%</span>';
        document.querySelector('.card-grid .card:nth-child(2) .card-value').textContent = 'Réinitialisé';
        document.querySelector('.card-grid .card:nth-child(2) .card-footer').textContent = 'Épisodes: 0';
        
        addLog('Modèle ML réinitialisé avec succès', 'success', 'mlLogs');
        showNot

        // Fonction de test blockchain pour diagnostiquer les problèmes de connexion
async function testBlockchainConnection() {
    try {
        addLog('Test de connexion blockchain...', 'info', 'all');
        
        // 1. Vérifier web3
        if (!web3) {
            throw new Error("Web3 n'est pas initialisé");
        }
        addLog('✅ Web3 est correctement initialisé', 'success', 'all');
        
        // 2. Vérifier les comptes
        const accounts = await web3.eth.getAccounts();
        if (!accounts || accounts.length === 0) {
            throw new Error("Aucun compte disponible");
        }
        addLog(`✅ Compte connecté: ${shortenAddress(accounts[0])}`, 'success', 'all');
        
        // 3. Vérifier le réseau
        const chainId = await web3.eth.getChainId();
        if (chainId !== 137) {
            throw new Error(`Réseau incorrect. Connecté à ${chainId}, Polygon est 137`);
        }
        addLog('✅ Connecté au réseau Polygon (ID: 137)', 'success', 'all');
        
        // 4. Vérifier le contrat
        if (!contract) {
            throw new Error("Contrat non initialisé");
        }
        
        const code = await web3.eth.getCode(contract.options.address);
        if (code === '0x' || code === '0x0') {
            throw new Error("Aucun code à l'adresse du contrat");
        }
        addLog(`✅ Contrat trouvé à l'adresse ${shortenAddress(contract.options.address)}`, 'success', 'all');
        
        // 5. Essayer une méthode view
        try {
            // Essayer avec isOperational si disponible
            if (contract.methods.isOperational) {
                await contract.methods.isOperational().call();
                addLog('✅ Méthode view appelée avec succès', 'success', 'all');
            } else {
                // Sinon essayer autre chose
                await web3.eth.getBalance(contract.options.address);
                addLog('✅ Solde du contrat récupéré avec succès', 'success', 'all');
            }
        } catch (viewError) {
            throw new Error(`Échec de l'appel à une méthode view: ${viewError.message}`);
        }
        
        // Envoyer un petit transaction de test?
        const doTestTx = confirm("Voulez-vous envoyer une petite transaction de test pour vérifier la connectivité complète?");
        
        if (doTestTx) {
            try {
                // Transaction minimale - transfert de 0 ETH à notre propre adresse
                const tx = await web3.eth.sendTransaction({
                    from: accounts[0],
                    to: accounts[0],
                    value: '0',
                    gas: '21000'
                });
                
                addLog(`✅ Transaction de test réussie! Hash: ${tx.transactionHash}`, 'success', 'all');
                addLog(`Vérifier sur Polygonscan: https://polygonscan.com/tx/${tx.transactionHash}`, 'info', 'all');
            } catch (txError) {
                throw new Error(`Échec de la transaction de test: ${txError.message}`);
            }
        }
        
        addLog('✅ Test de connexion blockchain réussi!', 'success', 'all');
        showNotification('Test réussi', 'La connexion blockchain est opérationnelle', 'success');
        
        return true;
    } catch (error) {
        console.error('Erreur de test blockchain:', error);
        addLog(`❌ Test échoué: ${error.message}`, 'error', 'all');
        showNotification('Test échoué', error.message, 'error');
        
        // Suggérer des solutions
        if (error.message.includes('réseau')) {
            addLog('⚠️ Solution: Changez de réseau vers Polygon dans MetaMask', 'warning', 'all');
        } else if (error.message.includes('compte')) {
            addLog('⚠️ Solution: Connectez-vous à votre portefeuille MetaMask', 'warning', 'all');
        } else if (error.message.includes('contrat')) {
            addLog('⚠️ Solution: Vérifiez l\'adresse du contrat dans les paramètres', 'warning', 'all');
        }
        
        return false;
    }
}
// Fonction de diagnostic à ajouter temporairement
function diagnosticFonctionsManquantes() {
    if (!window.contract) {
        console.error("Contrat non initialisé");
        return;
    }
    
    // Liste des fonctions attendues basée sur l'interface
    const fonctionsAttendues = [
        "forceExecuteFlashLoan",
        "directExecuteWMATICTrade",
        "isOperational",
        "checkArbitrageOpportunity",
        "emergencyWithdraw",
        "executeMultiHopArbitrage",
        "checkFlashLoanOpportunity",
        "checkLiquidationOpportunities",
        "executeLiquidation",
        "setMorpheusTrader",
        "setScannerService", 
        "setMLOptimizer",
        "getOptimalTradeRoute",
        "executeWithMorpheus",
        "morpheusTraderAddress",
        "scannerServiceAddress",
        "mlOptimizerAddress",
        "getScannerResults",
        "getMLPerformance",
        "resetMLOptimizer",
        "setAutomationEnabled",
        "findBestRoute",
        "updateMLParameters",
        "getContractBalance",
        "getProfitHistory",
        "getTradingLimits"
    ];
    
    // Vérifier quelles fonctions sont disponibles
    const fonctionsDisponibles = [];
    const fonctionsManquantes = [];
    
    fonctionsAttendues.forEach(fonction => {
        if (window.contract.methods[fonction]) {
            fonctionsDisponibles.push(fonction);
        } else {
            fonctionsManquantes.push(fonction);
        }
    });
    
    console.log("Fonctions disponibles:", fonctionsDisponibles);
    console.log("Fonctions manquantes:", fonctionsManquantes);
    
    // Ajouter à l'interface
    window.addLog(`Diagnostic: ${fonctionsManquantes.length} fonctions manquantes`, 'info', 'all');
    window.addLog(`Fonctions manquantes: ${fonctionsManquantes.join(', ')}`, 'info', 'all');
    
    return fonctionsManquantes;
}

// Exécuter le diagnostic après connexion
document.addEventListener('DOMContentLoaded', function() {
    // Attendre que le contrat soit initialisé
    setTimeout(() => {
        if (window.isConnected && window.contract) {
            diagnosticFonctionsManquantes();
        }
    }, 5000); // 5 secondes après chargement
});

// Ajouter un bouton de test dans l'interface
function addTestButton() {
    const testButton = document.createElement('button');
    testButton.innerHTML = '🔍 Tester la connexion blockchain';
    testButton.className = 'action-button';
    testButton.style.backgroundColor = '#2196f3';
    testButton.style.margin = '10px 0';
    testButton.onclick = testBlockchainConnection;
    
    // Ajouter à chaque panneau de logs
    const logContainers = [
        document.getElementById('flashloanLogs'), 
        document.getElementById('arbitrageLogs'), 
        document.getElementById('liquidationLogs')
    ];
    
    logContainers.forEach(container => {
        if (container) {
            const clone = testButton.cloneNode(true);
            clone.onclick = testBlockchainConnection;
            container.parentNode.insertBefore(clone, container);
        }
    });
}

// Ajouter le bouton de test au chargement
document.addEventListener('DOMContentLoaded', function() {
    const originalSetupEventListeners = setupEventListeners;
    
    // Redéfinir setupEventListeners pour inclure notre bouton de test
    window.setupEventListeners = function() {
        originalSetupEventListeners();
        addTestButton();
    };
});
</script>

<!-- Ajoutez juste ces deux scripts -->
<script src="https://cdn.jsdelivr.net/npm/web3@1.8.1/dist/web3.min.js"></script>
<script type="module" src="./extensions-init.js"></script>
<script src="maxbot-state-variable-fix.js"></script>
<!-- AVANT la balise </body> -->
<script src="maxbot-arbitrage-fix.js"></script>
<script src="maxbot-core-fixes.js"></script>
<script src="maxbot-trading-engine.js"></script>
<script src="contract-address-fix.js"></script>
<script src="maxbot-connection-fix.js"></script>
<script src="maxbot-operations.js"></script>
<script src="contract-address-simple-fix.js"></script>
<script src="maxbot-advanced-optimizations.js"></script>
<script src="maxbot-blockchain-monitor-fix.js"></script>
<script src="maxbot-integration.js"></script>
<script src="maxbot-abi-sync.js"></script>
<script src="maxbot-abi-emergency-fix.js"></script>
<!-- Importation des modules externes -->script

<script>
// Script d'initialisation des modules
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser les modules après chargement complet
    window.initModules = function() {
        // Initialiser MLOptimizer
        if (typeof MLOptimizer !== 'undefined') {
            window.mlOptimizer = new MLOptimizer();
            console.log('MLOptimizer initialisé');
        } else {
            console.error('MLOptimizer non disponible');
        }
        
        // Initialiser ScannerService
        if (typeof ScannerService !== 'undefined') {
            window.scannerService = new ScannerService();
            console.log('ScannerService initialisé');
        } else {
            console.error('ScannerService non disponible');
        }
        
        // Initialiser MorpheusTrader
        if (typeof MorpheusTrader !== 'undefined') {
            window.morpheusTrader = new MorpheusTrader();
            console.log('MorpheusTrader initialisé');
        } else {
            console.error('MorpheusTrader non disponible');
        }
    };
    
    // Exécuter l'initialisation avec un léger délai pour s'assurer que tout est chargé
    setTimeout(window.initModules, 1500);
});
</script>
<script src="emergency-link.js"></script>

<script src="script.js"></script>
/**
 * Code pour ajouter un lien vers le lanceur d'urgence MaxBot
 * Ajoutez ce script juste avant la fermeture de la balise </body> dans votre interface principale
 */
 (function() {
    // Crée l'élément du bouton d'urgence
    const emergencyButton = document.createElement('div');
    emergencyButton.innerHTML = `
        <div style="position: fixed; bottom: 20px; right: 20px; z-index: 9999;">
            <a href="maxbot-emergency.html" target="_blank" 
               style="display: flex; align-items: center; justify-content: center; 
                      width: 60px; height: 60px; 
                      background-color: #f44336; 
                      color: white; 
                      border-radius: 50%; 
                      font-size: 24px; 
                      text-decoration: none; 
                      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                      transition: all 0.3s ease;">⚡</a>
            <div style="position: absolute; 
                        bottom: -25px; 
                        left: 50%; 
                        transform: translateX(-50%); 
                        white-space: nowrap;
                        background-color: rgba(0,0,0,0.7);
                        color: white;
                        padding: 3px 8px;
                        border-radius: 4px;
                        font-size: 12px;
                        opacity: 0;
                        transition: opacity 0.3s ease;">Mode d'urgence</div>
        </div>
    `;

    // Ajoute des effets au survol
    const link = emergencyButton.querySelector('a');
    const tooltip = emergencyButton.querySelector('div > div');
    
    link.addEventListener('mouseover', function() {
        this.style.transform = 'scale(1.1)';
        tooltip.style.opacity = '1';
    });
    
    link.addEventListener('mouseout', function() {
        this.style.transform = 'scale(1)';
        tooltip.style.opacity = '0';
    });
    
    // Ajoute le bouton au document
    document.body.appendChild(emergencyButton);
    
    console.log('Lien vers le lanceur d\'urgence MaxBot ajouté');
})();
<!-- Script d'urgence pour contourner les problèmes d'intégration -->
<script>
    // Script d'urgence MaxBot
    async function runEmergencyArbitrage() {
        try {
            // Configuration de Web3 directement
            if (typeof ethereum !== 'undefined') {
                const web3 = new Web3(ethereum);
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                const account = accounts[0];
                
                // Vérifier le réseau
                const chainId = await web3.eth.getChainId();
                if (chainId !== 137) {
                    alert("Vous n'êtes pas sur le réseau Polygon. Veuillez changer de réseau.");
                    return false;
                }
                
                // Adresse du contrat et ABI minimal
                const contractAddress = "0xb6e34063afc9072d76353135918f2cb11a2e54a7";
                const abi = [
                    {"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"forceExecuteFlashLoan","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs":[{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"name":"executeMultiHopArbitrage","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs":[],"name":"emergencyWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}
                ];
                
                // Créer le contrat
                const contract = new web3.eth.Contract(abi, contractAddress);
                
                // Paramètres de l'arbitrage
                const USDC = "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174";
                const WMATIC = "0x0d500B1D8E8E53de6Ec5cB567F8Eff95819347C0";
                const amount = "700000000000"; // 700K USDC avec 6 décimales
                
                // Chemin d'arbitrage
                const path = [USDC, WMATIC, USDC];
                
                // Demander confirmation
                if (!confirm("Vous allez exécuter un arbitrage d'urgence avec 700,000 USDC. Continuer?")) {
                    return false;
                }
                
                // Exécuter
                const tx = await contract.methods.executeMultiHopArbitrage(path, amount).send({
                    from: account,
                    gas: 3000000
                });
                
                alert("Transaction envoyée: " + tx.transactionHash + "\nVoir sur Polygonscan: https://polygonscan.com/tx/" + tx.transactionHash);
                return true;
            } else {
                alert("MetaMask non détecté!");
                return false;
            }
        } catch (error) {
            alert("Erreur: " + error.message);
            console.error("Erreur d'arbitrage d'urgence:", error);
            return false;
        }
    }
    
    async function runEmergencyFlashLoan() {
        try {
            if (typeof ethereum !== 'undefined') {
                const web3 = new Web3(ethereum);
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                const account = accounts[0];
                
                // Vérifier le réseau
                const chainId = await web3.eth.getChainId();
                if (chainId !== 137) {
                    alert("Vous n'êtes pas sur le réseau Polygon. Veuillez changer de réseau.");
                    return false;
                }
                
                // Adresse du contrat et ABI minimal
                const contractAddress = "0xb6e34063afc9072d76353135918f2cb11a2e54a7";
                const abi = [
                    {"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"forceExecuteFlashLoan","outputs":[],"stateMutability":"nonpayable","type":"function"}
                ];
                
                // Créer le contrat
                const contract = new web3.eth.Contract(abi, contractAddress);
                
                // Paramètres du flash loan
                const USDC = "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174";
                const amount = "250000000000"; // 250K USDC avec 6 décimales
                
                // Demander confirmation
                if (!confirm("Vous allez exécuter un flash loan d'urgence avec 250,000 USDC. Continuer?")) {
                    return false;
                }
                
                // Exécuter
                const tx = await contract.methods.forceExecuteFlashLoan(USDC, amount).send({
                    from: account,
                    gas: 3000000
                });
                
                alert("Transaction envoyée: " + tx.transactionHash + "\nVoir sur Polygonscan: https://polygonscan.com/tx/" + tx.transactionHash);
                return true;
            } else {
                alert("MetaMask non détecté!");
                return false;
            }
        } catch (error) {
            alert("Erreur: " + error.message);
            console.error("Erreur de flash loan d'urgence:", error);
            return false;
        }
    }
    
    async function retrieveProfits() {
        try {
            if (typeof ethereum !== 'undefined') {
                const web3 = new Web3(ethereum);
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                const account = accounts[0];
                
                // Adresse du contrat et ABI minimal
                const contractAddress = "0x7b658e251ba658944c5905199fc53b9ad6425f5e";
                const abi = [
                    {"inputs":[],"name":"emergencyWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}
                ];
                
                // Créer le contrat
                const contract = new web3.eth.Contract(abi, contractAddress);
                
                // Demander confirmation
                if (!confirm("Cette opération tente de récupérer vos profits, mais nécessite généralement que le contrat soit en pause. Continuer?")) {
                    return false;
                }
                
                // Exécuter
                const tx = await contract.methods.emergencyWithdraw().send({
                    from: account,
                    gas: 300000
                });
                
                alert("Transaction envoyée: " + tx.transactionHash + "\nVoir sur Polygonscan: https://polygonscan.com/tx/" + tx.transactionHash);
                return true;
            } else {
                alert("MetaMask non détecté!");
                return false;
            }
        } catch (error) {
            alert("Erreur: " + error.message);
            console.error("Erreur de récupération des profits:", error);
            return false;
        }
    }
    
    // Ajouter les boutons d'urgence à l'interface
    // Fonction pour ajouter un bouton d'urgence réel
function addEmergencyButton() {
    // Crée l'élément du bouton d'urgence
    const emergencyButton = document.createElement('div');
    emergencyButton.innerHTML = `
        <div style="position: fixed; bottom: 20px; right: 20px; z-index: 9999;">
            <button id="emergencyWithdrawBtn" 
               style="display: flex; align-items: center; justify-content: center; 
                      width: 60px; height: 60px; 
                      background-color: #f44336; 
                      color: white; 
                      border-radius: 50%; 
                      font-size: 24px; 
                      border: none;
                      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                      cursor: pointer;
                      transition: all 0.3s ease;">⚡</button>
            <div style="position: absolute; 
                        bottom: -25px; 
                        left: 50%; 
                        transform: translateX(-50%); 
                        white-space: nowrap;
                        background-color: rgba(0,0,0,0.7);
                        color: white;
                        padding: 3px 8px;
                        border-radius: 4px;
                        font-size: 12px;">Récupération d'urgence</div>
        </div>
    `;

    // Ajoute le bouton au document
    document.body.appendChild(emergencyButton);
    
    // Configurer l'action du bouton d'urgence
    document.getElementById('emergencyWithdrawBtn').addEventListener('click', async function() {
        if (!isConnected) {
            showNotification('Non connecté', 'Veuillez vous connecter d\'abord', 'error');
            return;
        }
        
        if (!confirm('Voulez-vous vraiment exécuter la récupération d\'urgence? Cette action récupérera tous les fonds du contrat.')) {
            return;
        }
        
        try {
            addLog('Exécution de la récupération d\'urgence...', 'warning', 'all');
            
            const transaction = await contract.methods.emergencyWithdraw().send({
                from: userAccount,
                gas: 300000
            });
            
            addLog(`Récupération d'urgence réussie! Hash: ${transaction.transactionHash}`, 'success', 'all');
            showNotification('Succès', 'Récupération d\'urgence exécutée avec succès', 'success');
        } catch (error) {
            console.error('Erreur lors de la récupération d\'urgence:', error);
            addLog(`Erreur: ${error.message}`, 'error', 'all');
            showNotification('Erreur', error.message, 'error');
        }
    });
    
    console.log('Bouton d\'urgence ajouté');
}

// Ajouter le bouton d'urgence au chargement
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(addEmergencyButton, 2000); // Ajouter avec un délai pour s'assurer que la page est chargée
});
<!-- Solution de correction directe -->

// Correction directe pour l'initialisation du contrat
(function() {
    console.log("Exécution de la correction d'urgence...");
    
    // Réinitialisation Web3 et Contract
    function initializeContractEmergency() {
        console.log("Initialisation d'urgence du contrat...");
        
        try {
            // Créer une instance Web3 
            if (window.ethereum) {
                window.web3 = new Web3(window.ethereum);
                console.log("Web3 réinitialisé avec ethereum");
            } else if (window.web3) {
                window.web3 = new Web3(window.web3.currentProvider);
                console.log("Web3 réinitialisé avec currentProvider");
            } else {
                console.error("Aucun provider Web3 trouvé");
                return false;
            }
            
            // Récupérer l'adresse du contrat
            const contractAddress = document.getElementById('contract-address').value || '0xb6e34063afc9072d76353135918f2cb11a2e54a7';
            console.log("Utilisation de l'adresse du contrat:", contractAddress);
            
            // Vérifier que l'ABI est disponible
            if (typeof CONTRACT_ABI === 'undefined' || !CONTRACT_ABI) {
                console.error("L'ABI du contrat n'est pas défini");
                return false;
            }
            
            // Créer une nouvelle instance du contrat
            window.contract = new window.web3.eth.Contract(CONTRACT_ABI, contractAddress);
            console.log("Contrat réinitialisé:", window.contract ? "OK" : "ÉCHEC");
            
            // Vérifier si l'objet est correct
            if (window.contract && window.contract.methods) {
                console.log("Méthodes du contrat disponibles:", Object.keys(window.contract.methods).filter(m => !m.includes('0x')));
                return true;
            } else {
                console.error("L'initialisation du contrat a échoué");
                return false;
            }
        } catch (error) {
            console.error("Erreur lors de l'initialisation d'urgence:", error);
            return false;
        }
    }
    
    // Ajouter un bouton d'urgence
    function addEmergencyButton() {
        const fixButton = document.createElement('button');
        fixButton.textContent = "CORRECTION D'URGENCE";
        fixButton.style.cssText = "position: fixed; top: 10px; right: 10px; z-index: 9999; background-color: red; color: white; padding: 10px; border: none; cursor: pointer; font-weight: bold;";
        
        fixButton.addEventListener('click', function() {
            const success = initializeContractEmergency();
            
            if (success) {
                alert("Contrat réinitialisé avec succès! Essayez maintenant d'utiliser les fonctions.");
                fixButton.style.backgroundColor = "green";
                fixButton.textContent = "CORRECTION RÉUSSIE";
            } else {
                alert("Échec de la réinitialisation. Vérifiez la console pour plus de détails.");
            }
        });
        
        document.body.appendChild(fixButton);
        console.log("Bouton d'urgence ajouté");
    }
    
    // Attendez que le document soit chargé
    if (document.readyState === "complete" || document.readyState === "interactive") {
        setTimeout(addEmergencyButton, 1000);
    } else {
        document.addEventListener("DOMContentLoaded", function() {
            setTimeout(addEmergencyButton, 1000);
        });
    }
    
    // Vérifier si les objets existent déjà
    console.log("État actuel - web3:", typeof window.web3, "contract:", typeof window.contract);
    if (window.contract && window.contract.methods) {
        console.log("Le contrat semble déjà initialisé");
    } else {
        console.log("Le contrat n'est pas correctement initialisé");
    }
})();

// Tout le code du module MaxBotMaintenance ici
const MaxBotMaintenance = {
    // État du système
    systemStatus: {
        web3Connected: false,
        contractOperational: false,
        walletConnected: false,
        networkCorrect: false,
        pendingOperations: 0
    },
    
    // Initialisation du module
    initialize() {
        this.createMaintenanceButton();
        this.startBackgroundMonitoring();
        console.log("Module de maintenance initialisé");
    },
    
    // ... le reste du code ...
};

// Initialisation du module lors du chargement de la page
document.addEventListener('DOMContentLoaded', () => {
    MaxBotMaintenance.initialize();
});


</script>
<script>
  // Version ultra-simple - juste un bouton rouge vif
  const btn = document.createElement('button');
  btn.innerText = 'MAXBOT FIX';
  btn.style.position = 'fixed';
  btn.style.bottom = '20px';
  btn.style.right = '20px';
  btn.style.zIndex = '99999';
  btn.style.backgroundColor = 'red';
  btn.style.color = 'white';
  btn.style.padding = '15px';
  btn.style.fontSize = '18px';
  btn.style.fontWeight = 'bold';
  btn.style.border = 'none';
  btn.style.borderRadius = '5px';
  btn.onclick = function() { alert('Bouton cliqué!'); };
  document.body.appendChild(btn);
</script>
<script src="maxbot-trading-engine.js"></script>
<script src="maxbot-web3-fix.js"></script>
<script src="MLOptimizer.js"></script>
<script src="ScannerService.js"></script>
<script src="MorpheusTrader.js"></script>
<!-- Dans votre HTML, avant la fermeture de la balise </body> -->
<script src="MaxBotOrchestrator.js"></script>
<script src="maxbot-integration.js"></script>
<script src="contract-address-fix.js"></script>
<script src="maxbot-contract-fix.js"></script>
<script src="web3-fix.js"></script>/**
 * MaxBotHealthKit Repair Tool v1.0
 * 
 * Cet outil analyse, répare et reconstruit automatiquement le code MaxBotHealthKit v3.0.
 * Il corrige les problèmes courants et génère une version fonctionnelle du code.
 * 
 * Fonctionnalités:
 * - Analyse et extrait tous les modules (SecurityUtils, MemoryCache, etc.)
 * - Corrige les sections de code fragmentées
 * - Restaure les méthodes incomplètes
 * - Équilibre les accolades manquantes ou en trop
 * - Ajoute des implémentations temporaires pour les méthodes manquantes
 * - Reconstruit une version nettoyée et fonctionnelle du code
 * 
 * Mode d'emploi:
 * 1. Copiez tout le code MaxBotHealthKit original dans la zone de texte de l'interface
 * 2. Cliquez sur le bouton "Réparer le code"
 * 3. Le code réparé sera téléchargé automatiquement
 */

// CONFIGURATION: Collez votre code MaxBotHealthKit complet ici
let CODE_TO_FIX = `
/**
 * MaxBotHealthKit v3.0
 * Outil haute performance pour MaxBot avec focus sur la capture rapide d'opportunités
 * 
 * Améliorations:
 * - Exécution en temps réel au lieu de simulations
 * - Optimisation pour la détection rapide d'opportunités
 * - Architecture modulaire avec performance accrue
 * - Sécurité renforcée et validations strictes
 * - Mémoire cache pour réduire les appels blockchain
 * - Support multi-chaînes amélioré
 * - Mécanisme avancé d'estimation du gas
 */

// Configuration initiale et constantes
const MAX_CONCURRENT_TASKS = 5;
const STORAGE_PREFIX = 'maxbot_';
const DEFAULT_PRIORITY = 3;
const CACHE_DURATION_MS = 10000; // 10 secondes
const DEFAULT_GAS_BOOST = 1.2; // 20% boost par défaut

// Collez votre code MaxBotHealthKit v3.0 complet ici pour réparation
`;

// Constantes et utilitaires de l'outil
const MODULES = [
  'SecurityUtils',
  'MemoryCache',
  'Logger',
  'TaskManager',
  'ErrorParser',
  'GasOptimizer',
  'ChainManager',
  'OpportunityManager',
  'UserInterface',
  'MaxBotHealthKit'
];

// Fonctionnalités principales de réparation
const MaxBotRepairTool = {
  // État interne
  originalCode: '',
  fixedCode: '',
  moduleDefinitions: {},
  moduleBlocks: {},
  brokenModules: [],
  fixedModules: [],
  extractedMethods: {},
  errorLog: [],

  // Initialiser l'outil avec le code
  initialize(code) {
    this.originalCode = code;
    this.fixedCode = '';
    this.moduleDefinitions = {};
    this.moduleBlocks = {};
    this.brokenModules = [];
    this.fixedModules = [];
    this.extractedMethods = {};
    this.errorLog = [];
    
    console.log('📊 Outil de réparation MaxBotHealthKit initialisé');
    return true;
  },

  // Exécuter toutes les étapes de réparation
  async repairCode() {
    console.log('🔧 Début du processus de réparation...');
    
    // Étape 1: Extraire les modules
    this.extractModules();
    
    // Étape 2: Analyser et corriger les sections fragmentées
    this.findFragmentedSections();
    
    // Étape 3: Extraire les méthodes de chaque module
    this.extractMethods();
    
    // Étape 4: Reconstruction des modules
    this.reconstructModules();
    
    // Étape 5: Reconstituer le code complet
    this.rebuildCode();
    
    // Étape 6: Corriger les erreurs communes
    this.fixCommonErrors();
    
    // Étape 7: Ajouter le code d'initialisation
    this.addInitializationCode();
    
    console.log('✅ Réparation terminée');
    
    // Exporter le résultat
    this.exportFixedCode();
    
    return {
      originalSize: this.originalCode.length,
      fixedSize: this.fixedCode.length,
      fixedModules: this.fixedModules,
      brokenModules: this.brokenModules,
      errors: this.errorLog
    };
  },

  // Extraire tous les modules du code
  extractModules() {
    console.log('🔍 Extraction des modules...');
    
    // Rechercher les déclarations de modules
    const moduleRegex = /(?:const|let|var)\s+([A-Z][A-Za-z0-9_]+)\s*=\s*\{/g;
    let match;
    
    while ((match = moduleRegex.exec(this.originalCode)) !== null) {
      const moduleName = match[1];
      const moduleStart = match.index;
      
      // Éviter les duplications
      if (this.moduleDefinitions[moduleName]) continue;
      
      // Trouver la définition complète du module
      this.moduleDefinitions[moduleName] = {
        name: moduleName,
        start: moduleStart,
        content: ''
      };
      
      console.log(`📦 Module trouvé: ${moduleName}`);
    }
    
    // Pour chaque module connu, essayer de trouver son bloc de code
    for (const moduleName of MODULES) {
      if (this.moduleDefinitions[moduleName]) {
        this.findModuleContent(moduleName);
      } else {
        console.warn(`⚠️ Module non trouvé: ${moduleName}`);
        this.brokenModules.push(moduleName);
      }
    }
    
    console.log(`📊 Extraction terminée: ${Object.keys(this.moduleBlocks).length} modules extraits`);
  },

  // Trouver le contenu d'un module
  findModuleContent(moduleName) {
    const moduleLines = [];
    const blocks = [];
    
    // Trouver tous les blocs potentiels pour ce module
    const moduleBlockRegex = new RegExp(`(?:const|let|var)\\s+${moduleName}\\s*=\\s*\\{([\\s\\S]*?)\\};`, 'g');
    let blockMatch;
    
    while ((blockMatch = moduleBlockRegex.exec(this.originalCode)) !== null) {
      blocks.push(blockMatch[1]);
    }
    
    // Chercher tous les blocs contenant ce module
    const fragmentRegex = new RegExp(`\\b${moduleName}\\b[\\s\\S]*?\\{([\\s\\S]*?)\\n\\}`, 'g');
    let fragmentMatch;
    
    while ((fragmentMatch = fragmentRegex.exec(this.originalCode)) !== null) {
      // Vérifier que c'est un fragment de ce module et pas un autre
      const contextBefore = this.originalCode.substring(Math.max(0, fragmentMatch.index - 50), fragmentMatch.index);
      if (contextBefore.includes(moduleName)) {
        blocks.push(fragmentMatch[1]);
      }
    }
    
    if (blocks.length > 0) {
      // Fusionner tous les blocs trouvés
      this.moduleBlocks[moduleName] = blocks.join('\n\n    ');
      this.fixedModules.push(moduleName);
    } else {
      console.warn(`⚠️ Contenu non trouvé pour le module: ${moduleName}`);
      this.brokenModules.push(moduleName);
    }
  },

  // Trouver et corriger les sections fragmentées
  findFragmentedSections() {
    console.log('🧩 Recherche de sections fragmentées...');
    
    // Pour chaque module, rechercher les sections qui pourraient être fragmentées
    for (const moduleName in this.moduleBlocks) {
      const content = this.moduleBlocks[moduleName];
      
      // Vérifier les sections potentiellement incomplètes
      const incompleteMethodRegex = /([a-zA-Z0-9_]+)\s*:\s*(?:async\s+)?function\s*\([^{]*\{(?:[^{}]*\{[^{}]*\})*[^{}]*(?!\}\s*,|\}\s*$)/g;
      let match;
      
      while ((match = incompleteMethodRegex.exec(content)) !== null) {
        const methodName = match[1];
        
        // Rechercher d'autres parties de cette méthode dans le code original
        const methodRegex = new RegExp(`\\b${moduleName}\\b[\\s\\S]*?\\b${methodName}\\b[\\s\\S]*?\\{([\\s\\S]*?)\\n\\s*\\}`, 'g');
        const methodParts = [];
        let methodMatch;
        
        while ((methodMatch = methodRegex.exec(this.originalCode)) !== null) {
          methodParts.push(methodMatch[1]);
        }
        
        if (methodParts.length > 1) {
          console.log(`🔄 Méthode fragmentée trouvée: ${moduleName}.${methodName}`);
          
          // Remplacer la méthode incomplète par la version consolidée
          const methodContent = methodParts.join('\n');
          
          // Mise à jour du contenu du module
          this.moduleBlocks[moduleName] = this.moduleBlocks[moduleName].replace(
            new RegExp(`${methodName}\\s*:\\s*(?:async\\s+)?function\\s*\\([^{]*\\{[^}]*`),
            `${methodName}: function(${this.extractParameters(methodName, moduleName)}) {\n        ${methodContent}`
          );
        }
      }
    }
  },

  // Extraire les méthodes de chaque module
  extractMethods() {
    console.log('📋 Extraction des méthodes...');
    
    for (const moduleName in this.moduleBlocks) {
      const methods = [];
      const methodRegex = /([a-zA-Z0-9_]+)\s*:\s*(?:async\s+)?function|\b([a-zA-Z0-9_]+)\s*\([^)]*\)\s*{/g;
      let match;
      
      const content = this.moduleBlocks[moduleName];
      while ((match = methodRegex.exec(content)) !== null) {
        const methodName = match[1] || match[2];
        if (methodName && !methods.includes(methodName)) {
          methods.push(methodName);
        }
      }
      
      this.extractedMethods[moduleName] = methods;
      console.log(`📊 Module ${moduleName}: ${methods.length} méthodes trouvées`);
    }
  },

  // Extraire les paramètres d'une méthode
  extractParameters(methodName, moduleName) {
    const methodRegex = new RegExp(`\\b${methodName}\\s*(?::\\s*(?:async\\s+)?function\\s*)?\\(([^)]*)\\)`, 'g');
    let match;
    
    while ((match = methodRegex.exec(this.originalCode)) !== null) {
      // Vérifier que c'est bien une méthode du module
      const contextBefore = this.originalCode.substring(Math.max(0, match.index - 100), match.index);
      if (contextBefore.includes(moduleName)) {
        return match[1];
      }
    }
    
    return '';
  },

  // Reconstruire les modules avec leurs méthodes
  reconstructModules() {
    console.log('🏗️ Reconstruction des modules...');
    
    for (const moduleName in this.moduleBlocks) {
      let moduleContent = this.moduleBlocks[moduleName];
      
      // Vérifier si le contenu comporte des erreurs évidentes
      if (this.hasStructuralErrors(moduleContent)) {
        console.warn(`⚠️ Erreurs structurelles détectées dans le module ${moduleName}`);
        this.errorLog.push(`Erreurs structurelles dans ${moduleName}`);
        
        // Tentative de réparation des accolades manquantes
        moduleContent = this.balanceBraces(moduleContent);
      }
      
      // Standardiser le contenu du module
      moduleContent = this.standardizeModuleContent(moduleContent, moduleName);
      
      // Mettre à jour le contenu du module
      this.moduleBlocks[moduleName] = moduleContent;
    }
  },

  // Vérifier si le contenu a des erreurs structurelles
  hasStructuralErrors(content) {
    let braceCount = 0;
    
    for (const char of content) {
      if (char === '{') braceCount++;
      else if (char === '}') braceCount--;
      
      if (braceCount < 0) return true; // Plus d'accolades fermantes qu'ouvrantes
    }
    
    return braceCount !== 0; // Déséquilibre d'accolades
  },

  // Équilibrer les accolades
  balanceBraces(content) {
    let braceCount = 0;
    
    for (const char of content) {
      if (char === '{') braceCount++;
      else if (char === '}') braceCount--;
    }
    
    // Ajouter les accolades manquantes
    if (braceCount > 0) {
      // Accolades ouvrantes non fermées
      for (let i = 0; i < braceCount; i++) {
        content += '\n    }';
      }
    } else if (braceCount < 0) {
      // Plus d'accolades fermantes que nécessaire
      // Enlever les accolades fermantes en trop ou ajouter des ouvrantes au début
      for (let i = 0; i < Math.abs(braceCount); i++) {
        content = '{\n    ' + content;
      }
    }
    
    return content;
  },

  // Standardiser le contenu d'un module
  standardizeModuleContent(content, moduleName) {
    // Supprimer les espaces en début et fin
    content = content.trim();
    
    // Normaliser l'indentation
    content = content.replace(/\n\s+/g, '\n    ');
    
    // S'assurer que chaque méthode se termine correctement
    const methods = this.extractedMethods[moduleName] || [];
    for (const method of methods) {
      const methodRegex = new RegExp(`${method}\\s*:\\s*(?:async\\s+)?function\\s*\\([^{]*\\{[^]*?(?=\\n\\s*[a-zA-Z0-9_]+\\s*:)`, 'g');
      const match = methodRegex.exec(content);
      
      if (match && !match[0].trim().endsWith('}')) {
        // Méthode incomplète, ajouter l'accolade fermante
        content = content.replace(methodRegex, match[0] + '\n    }');
      }
    }
    
    // Vérifier la dernière méthode
    if (methods.length > 0) {
      const lastMethod = methods[methods.length - 1];
      if (!content.includes(`${lastMethod}:`) || !content.endsWith('}')) {
        // S'assurer que la dernière méthode se termine correctement
        if (!content.endsWith('}')) {
          content += '\n    }';
        }
      }
    }
    
    return content;
  },

  // Reconstruire le code complet
  rebuildCode() {
    console.log('🔄 Reconstruction du code complet...');
    
    let fixedCode = `/**
 * MaxBotHealthKit v3.0 (Code réparé)
 * Outil haute performance pour MaxBot avec focus sur la capture rapide d'opportunités
 * 
 * Améliorations:
 * - Exécution en temps réel au lieu de simulations
 * - Optimisation pour la détection rapide d'opportunités
 * - Architecture modulaire avec performance accrue
 * - Sécurité renforcée et validations strictes
 * - Mémoire cache pour réduire les appels blockchain
 * - Support multi-chaînes amélioré
 * - Mécanisme avancé d'estimation du gas
 */

// Configuration initiale et constantes
const MAX_CONCURRENT_TASKS = 5;
const STORAGE_PREFIX = 'maxbot_';
const DEFAULT_PRIORITY = 3;
const CACHE_DURATION_MS = 10000; // 10 secondes
const DEFAULT_GAS_BOOST = 1.2; // 20% boost par défaut

`;
    
    // Ajouter chaque module dans l'ordre spécifié
    for (const moduleName of MODULES) {
      if (this.moduleBlocks[moduleName]) {
        fixedCode += `// Module ${moduleName}
const ${moduleName} = {
    ${this.moduleBlocks[moduleName]}
};

`;
      } else if (this.brokenModules.includes(moduleName)) {
        // Module manquant - ajouter un stub
        fixedCode += this.createModuleStub(moduleName);
      }
    }
    
    this.fixedCode = fixedCode;
  },

  // Créer un stub pour un module manquant
  createModuleStub(moduleName) {
    console.warn(`⚠️ Création d'un stub pour le module manquant: ${moduleName}`);
    
    // Stubs spécifiques pour chaque module
    const moduleStubs = {
      SecurityUtils: `// Module SecurityUtils (Stub)
const SecurityUtils = {
    validateAddress(address) {
        if (!address || typeof address !== 'string') return false;
        return /^0x[a-fA-F0-9]{40}$/.test(address);
    },
    
    validateAmount(amount) {
        if (!amount) return false;
        try {
            const bigIntAmount = BigInt(amount);
            return bigIntAmount > 0;
        } catch (e) {
            return false;
        }
    },
    
    sanitizeInput(input) {
        if (typeof input !== 'string') return '';
        return input.replace(/<[^>]*>?/gm, ''); // Supprime les tags HTML
    },
    
    secureStorage: {
        set(key, value) {
            try {
                const timestamp = Date.now();
                const storageObj = {
                    value,
                    timestamp,
                    checksum: this._calculateChecksum(key, value, timestamp)
                };
                localStorage.setItem(\`\${STORAGE_PREFIX}\${key}\`, JSON.stringify(storageObj));
                return true;
            } catch (e) {
                console.error('Erreur de stockage:', e);
                return false;
            }
        },
        
        get(key) {
            try {
                const storageData = localStorage.getItem(\`\${STORAGE_PREFIX}\${key}\`);
                if (!storageData) return null;
                
                const storageObj = JSON.parse(storageData);
                const { value, timestamp, checksum } = storageObj;
                
                // Vérifier l'intégrité
                if (checksum !== this._calculateChecksum(key, value, timestamp)) {
                    console.warn('Intégrité du stockage compromise');
                    return null;
                }
                
                return value;
            } catch (e) {
                console.error('Erreur de récupération:', e);
                return null;
            }
        },
        
        _calculateChecksum(key, value, timestamp) {
            // Simple fonction de hachage pour vérifier l'intégrité
            const valueStr = typeof value === 'object' ? JSON.stringify(value) : String(value);
            let hash = 0;
            const str = \`\${key}:\${valueStr}:\${timestamp}\`;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            return hash.toString(36);
        }
    }
};

`,
      MemoryCache: `// Module MemoryCache (Stub)
const MemoryCache = {
    _cache: new Map(),
    
    get(key) {
        if (!this._cache.has(key)) return null;
        
        const { value, expiry } = this._cache.get(key);
        if (Date.now() > expiry) {
            this._cache.delete(key);
            return null;
        }
        
        return value;
    },
    
    set(key, value, ttlMs = CACHE_DURATION_MS) {
        this._cache.set(key, {
            value,
            expiry: Date.now() + ttlMs
        });
    },
    
    invalidate(keyPattern) {
        if (keyPattern instanceof RegExp) {
            for (const key of this._cache.keys()) {
                if (keyPattern.test(key)) {
                    this._cache.delete(key);
                }
            }
        } else {
            this._cache.delete(keyPattern);
        }
    },
    
    clear() {
        this._cache.clear();
    }
};

`,
      Logger: `// Module Logger (Stub)
const Logger = {
    LEVELS: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        CRITICAL: 4
    },
    
    _currentLevel: 1, // INFO par défaut
    _logs: [],
    _maxLogs: 100,
    
    init(level = 1, maxLogs = 100) {
        this._currentLevel = level;
        this._maxLogs = maxLogs;
        return this;
    },
    
    setLevel(level) {
        this._currentLevel = level;
    },
    
    log(level, context, message, data = null) {
        if (level < this._currentLevel) return;
        
        const entry = {
            timestamp: Date.now(),
            level,
            context,
            message,
            data
        };
        
        // Ajouter au journal en mémoire
        this._logs.unshift(entry);
        
        // Limiter la taille du journal
        if (this._logs.length > this._maxLogs) {
            this._logs.pop();
        }
        
        // Afficher dans la console
        const levelName = Object.keys(this.LEVELS).find(key => this.LEVELS[key] === level) || 'INFO';
        console[level >= this.LEVELS.ERROR ? 'error' : level >= this.LEVELS.WARN ? 'warn' : 'log'](
            \`[\${new Date().toISOString()}] [\${levelName}] [\${context}] \${message}\`,
            data || ''
        );
        
        return entry;
    },
    
    debug(context, message, data = null) {
        return this.log(this.LEVELS.DEBUG, context, message, data);
    },
    
    info(context, message, data = null) {
        return this.log(this.LEVELS.INFO, context, message, data);
    },
    
    warn(context, message, data = null) {
        return this.log(this.LEVELS.WARN, context, message, data);
    },
    
    error(context, message, data = null) {
        return this.log(this.LEVELS.ERROR, context, message, data);
    },
    
    critical(context, message, data = null) {
        return this.log(this.LEVELS.CRITICAL, context, message, data);
    },
    
    getLogs(level = null, count = null) {
        let filtered = this._logs;
        
        if (level !== null) {
            filtered = filtered.filter(log => log.level >= level);
        }
        
        if (count !== null) {
            filtered = filtered.slice(0, count);
        }
        
        return filtered;
    },
    
    clearLogs() {
        this._logs = [];
    }
};

`
    };
    
    // Retourner le stub approprié ou un stub générique
    return moduleStubs[moduleName] || `// Module ${moduleName} (Stub)
const ${moduleName} = {
    // Stub pour le module manquant
    _isStub: true,
    
    init() {
        console.warn("Module ${moduleName} non implémenté (utilisation d'un stub)");
        return Promise.resolve(false);
    }
};

`;
  },

  // Corriger les erreurs courantes
  fixCommonErrors() {
    console.log('🔧 Correction des erreurs courantes...');
    
    // 1. Corriger les méthodes d'implémentation DEX manquantes
    if (this.moduleBlocks['OpportunityManager'] && 
        !this.moduleBlocks['OpportunityManager'].includes('_getUniswapRate') && 
        !this.moduleBlocks['OpportunityManager'].includes('return null')) {
      
      // Ajouter les implémentations DEX temporaires
      this.fixedCode = this.fixedCode.replace(
        /OpportunityManager = {/,
        `OpportunityManager = {
    // Implémentations temporaires pour les méthodes DEX
    async _getUniswapRate(tokenFrom, tokenTo) {
        // Implémentation temporaire pour test
        return Math.random() * (1.05 - 0.95) + 0.95; // Valeur entre 0.95 et 1.05
    },
    
    async _getSushiswapRate(tokenFrom, tokenTo) {
        // Implémentation temporaire pour test
        return Math.random() * (1.05 - 0.95) + 0.95; // Valeur entre 0.95 et 1.05
    },
    
    async _getQuickswapRate(tokenFrom, tokenTo) {
        // Implémentation temporaire pour test
        return Math.random() * (1.05 - 0.95) + 0.95; // Valeur entre 0.95 et 1.05
    },`
      );
    }
    
    // 2. Corriger les problèmes de méthodes manquantes
    if (this.fixedCode.includes('ErrorParser.parseBlockchainError') && 
        !this.fixedCode.includes('parseBlockchainError(error)')) {
      
      this.fixedCode = this.fixedCode.replace(
        /ErrorParser = {/,
        `ErrorParser = {
    parseBlockchainError(error) {
        try {
            const errorString = error.message || error.toString();
            let parsed = {
                originalError: error,
                message: errorString,
                code: 'UNKNOWN_ERROR',
                suggestion: 'Vérifiez les paramètres et réessayez'
            };
            
            // Analyse de l'erreur et retour du résultat
            return parsed;
        } catch (e) {
            console.error('Erreur lors de l\\'analyse d\\'erreur', e);
            return {
                originalError: error,
                message: error.message || 'Erreur inconnue',
                code: 'PARSE_FAILED',
                suggestion: 'Une erreur s\\'est produite, vérifiez les détails dans la console'
            };
        }
    },`
      );
    }
    
    // 3. Corriger les problèmes de fonctions en double
    this.fixedCode = this.fixedCode.replace(/(function[^{]*\{[\s\S]*?\})\s*\1/g, '$1');
    
    // 4. Supprimer les lignes dupliquées
    const lines = this.fixedCode.split('\n');
    const uniqueLines = [];
    const seen = new Set();
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine && !seen.has(trimmedLine)) {
        seen.add(trimmedLine);
        uniqueLines.push(line);
      }
    }
    
    this.fixedCode = uniqueLines.join('\n');
  },

  // Ajouter le code d'initialisation
  addInitializationCode() {
    console.log('📝 Ajout du code d\'initialisation...');
    
    this.fixedCode += `
// Initialiser le module lors du chargement du document
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser MaxBotHealthKit si non déjà fait
    if (!MaxBotHealthKit.isInitialized()) {
        MaxBotHealthKit.initialize()
            .then(success => {
                if (success) {
                    console.log('MaxBotHealthKit initialisé avec succès');
                } else {
                    console.error('Échec de l\\'initialisation de MaxBotHealthKit');
                }
            })
            .catch(error => {
                console.error('Erreur lors de l\\'initialisation de MaxBotHealthKit:', error);
            });
    }
});

// Exposer globalement
window.MaxBotHealthKit = MaxBotHealthKit;
`;

// Initialisation automatique quand le script est chargé dans un navigateur
(function() {
  // Vérifier si nous sommes dans un navigateur
  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    // Attendre que le DOM soit chargé
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', createUI);
    } else {
      createUI();
    }
    
    // Ajouter des styles CSS pour l'interface
    const styles = document.createElement('style');
    styles.textContent = `
      #maxbot-repair-container {
        animation: fadeIn 0.5s ease-in-out;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      #repair-button:hover {
        background-color: #2980b9 !important;
      }
      
      #download-button:hover {
        background-color: #27ae60 !important;
      }
      
      #code-input:focus {
        border-color: #3498db !important;
        outline: none;
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
      }
    `;
    document.head.appendChild(styles);
    
    console.log('%c MaxBotHealthKit Repair Tool v1.0 %c Prêt à l\'emploi', 
      'background: #3498db; color: white; padding: 4px; border-radius: 4px 0 0 4px;', 
      'background: #2ecc71; color: white; padding: 4px; border-radius: 0 4px 4px 0;');
  } else {
    // Environnement Node.js ou autre
    console.log('MaxBotHealthKit Repair Tool v1.0 est prêt à être utilisé.');
    console.log('Pour lancer la réparation, utilisez: MaxBotRepairTool.initialize(code) puis MaxBotRepairTool.repairCode()');
  }
})();
  },

  // Exporter le code réparé
  exportFixedCode() {
    console.log('💾 Exportation du code réparé...');
    
    // Créer un lien de téléchargement
    const element = document.createElement('a');
    const file = new Blob([this.fixedCode], {type: 'text/javascript'});
    element.href = URL.createObjectURL(file);
    element.download = 'MaxBotHealthKit-repaired.js';
    element.style.display = 'none';
    
    // Déclencher le téléchargement
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    
    console.log('✅ Code réparé exporté avec succès!');
    
    // Mise à jour de l'interface utilisateur
    if (document.getElementById('result-container')) {
      document.getElementById('result-container').style.display = 'block';
      
      // Afficher les statistiques
      const statsContainer = document.getElementById('repair-stats');
      if (statsContainer) {
        statsContainer.innerHTML = `
          <p><strong>Taille originale:</strong> ${this.originalCode.length} caractères</p>
          <p><strong>Taille après réparation:</strong> ${this.fixedCode.length} caractères</p>
          <p><strong>Modules traités:</strong> ${this.fixedModules.length + this.brokenModules.length}</p>
        `;
      }
      
      // Afficher les modules réparés
      const modulesContainer = document.getElementById('modules-fixed');
      if (modulesContainer) {
        let modulesHtml = '<h3>Modules traités:</h3><ul>';
        
        for (const module of this.fixedModules) {
          modulesHtml += `<li><span style="color: #2ecc71;">✓</span> ${module}</li>`;
        }
        
        for (const module of this.brokenModules) {
          modulesHtml += `<li><span style="color: #e74c3c;">⚠️</span> ${module} (stub créé)</li>`;
        }
        
        modulesHtml += '</ul>';
        modulesContainer.innerHTML = modulesHtml;
      }
      
      // Afficher les erreurs détectées
      const errorContainer = document.getElementById('error-log');
      if (errorContainer) {
        if (this.errorLog.length > 0) {
          let errorHtml = '<h3>Problèmes détectés:</h3><ul>';
          
          for (const error of this.errorLog) {
            errorHtml += `<li><span style="color: #e74c3c;">⚠️</span> ${error}</li>`;
          }
          
          errorHtml += '</ul>';
          errorContainer.innerHTML = errorHtml;
        } else {
          errorContainer.innerHTML = '<p><span style="color: #2ecc71;">✓</span> Aucune erreur critique détectée</p>';
        }
      }
    }
    
    return this.fixedCode;
  }
};

/**
 * Interface graphique simple pour utiliser l'outil de réparation
 */
function createUI() {
  // Créer une interface utilisateur basique
  const container = document.createElement('div');
  container.id = 'maxbot-repair-container';
  container.style = `
    font-family: Arial, sans-serif;
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  `;
  
  // Contenu de l'interface
  container.innerHTML = `
    <h1 style="color: #3498db; margin-top: 0;">MaxBotHealthKit Repair Tool</h1>
    <p>Cet outil analyse et répare automatiquement le code MaxBotHealthKit v3.0 pour corriger les erreurs courantes.</p>
    
    <div style="margin: 20px 0; padding: 15px; background-color: #f8f9fa; border-left: 4px solid #3498db; border-radius: 4px;">
      <p style="margin: 0 0 10px 0; font-weight: bold;">Mode d'emploi:</p>
      <ol style="margin: 0; padding-left: 20px;">
        <li>Collez votre code MaxBotHealthKit v3.0 dans la zone de texte ci-dessous</li>
        <li>Cliquez sur le bouton "Réparer le code"</li>
        <li>Le code réparé sera automatiquement téléchargé sur votre ordinateur</li>
      </ol>
    </div>
    
    <div style="margin-bottom: 15px;">
      <label for="code-input" style="display: block; margin-bottom: 5px; font-weight: bold;">Code à réparer:</label>
      <textarea id="code-input" style="width: 100%; height: 200px; font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 4px;" placeholder="Collez ici le code MaxBotHealthKit v3.0 à réparer..."></textarea>
    </div>
    
    <button id="repair-button" style="background-color: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">Réparer le code</button>
    
    <div id="result-container" style="margin-top: 20px; display: none;">
      <h2 style="color: #3498db;">Résultats de la réparation</h2>
      
      <div id="repair-stats" style="margin-bottom: 15px; padding: 15px; background-color: #f8f9fa; border-radius: 4px;"></div>
      
      <div id="modules-fixed" style="margin-bottom: 15px;"></div>
      
      <div id="error-log" style="margin-bottom: 15px;"></div>
      
      <p style="font-weight: bold;">Le code réparé a été téléchargé automatiquement. Si le téléchargement n'a pas commencé, cliquez sur le bouton ci-dessous:</p>
      
      <button id="download-button" style="background-color: #2ecc71; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">
        <span style="margin-right: 5px;">⬇️</span> Télécharger le code réparé
      </button>
    </div>
<script src="realTradingSystem.js"></script>
<script src="abi-fix.js"></script>
<script src="maxbot-utility-fix.js"></script>
<script src="maxbot-state-variable-fix.js"></script>
<script src="maxbot-arbitrage-fix.js"></script>
<script src="path/to/maxbot-maintenance.js"></script>
<script src="maxbot-blockchain-fix.js"></script>
<script src="token-validator.js"></script>
<script src="flashloan-validator.js"></script>
<script src="maxbot-controller.js"></script>
<script src="maxbotApi.js"></script>
<script src="maxbot-rpc-mev-fix.js"></script>
<script src="chemin/vers/MaxBotHealthKit.js"></script>
<script src="chemin/vers/MaxBotHealthKit-Repair.js"></script>
<script src="maxbot-health-kit.js"></script>
<script src="chemin/vers/RPCErrorFixerPro.js"></script>
</script>
</body>
</html>
